---
title: 操作系统的“公理化”
date: 2022-08-30 15:05:26
tags: 
  - 操作系统
  - Linux Kernel
  - 特权级
  - 授权
categories: 操作系统高级教程课堂笔记
description: 国科大杨力祥《操作系统高级教程》课堂笔记1 —— 为什么需要内核
cover: https://s3.bmp.ovh/imgs/2022/08/30/57e6003529c041b7.webp
---

> - 源码阅读工具：Source Insight
> - 关键字:
>     - 内核Kernel
>     - 特权级
>     - 授权
> - 主要内容：本节课主要探讨了Linux内核，老师从逻辑推理的角度带大家体会什么是内核，为什么需要内核。

# 授权

## 观点：未经授权，不得访问其他用户的资源
> 访问自己的资源，总是授权的。

## 探讨

### 问题：未经许可，用户是否能访问外设（IO）中自己的资源？
- 答案：不可以。
- 原因：IO物理端口只有一个，而用户程序具有不确定性（可能会做一些坏事），如果开放端口，可能会无法控制。
- 解决办法：若用户非要访问（IO指令/MMIO），则用特权级拦住。
    - 特权级：CPU剥夺了应用程序访问外设的能力。

### 问题：而自己的资源，应该要能访问的，那怎么办？
- 因为：用户进程是不确定的，并且它应该是不确定的，没有理由要求它确定。
- 由**一组确定的程序**来访问自己的资源————即**内核**。

# 特权级

## 特权级的概念

在linux系统中特权级别分为0，1，2，3一共四个级别，0最大 ，3最小。
- 一般内核代码运行在0特权级；
- 驱动、虚拟机等运行在1，2特权级；
- 而我们自己写的程序一般运行在3特权级，也就是最低级别。

## 探讨
### 用户程序指令（3特权）为什么不能访问0特权的数据？
答：因为用户程序指令具有不确定性。

### 0特权能否直接跳到3特权？
答：不允许，若此时0特权跳转过去后仍保持全态，那么应用程序就会直接变为kernel。

# 接续访问机制

**接续访问机制**：用户发起 -> 内核接续（IO行为） -> 交付用户

## 观点：内核的工作，是用户进程访问行为的延续

## 观点：内核需要结构化，提供一组自洽的、一致的syscall

## 提问：既然未经授权，不得访问其他用户的资源。那所谓授权，又是给谁的？

思考：
- 给用户？同一个用户，有可能可以读A文件，而B文件不行；
- 给资源？同一份资源，有可能用户1可以读，而用户2不行。

答：给"访问"：一般是三元组（用户，操作，资源）。即**一次授权对应一次访问**

## 提问：从用户发起到内核接续，也即不确定行为到确定行为，如何实现？
答：1. 反转状态；2. 要求转移指令确定的落点：（1）限制用户进程的跳转指令；（2）限制用户进程的跳转落点.

> 补充：以RISC-V为例，（1）只能是ecall指令；（2）只能是mtvec，中断向量基址，该值由OS内核指定。

## 观点：接续访问机制的重要保障：用户态和内核态之间有面"墙"

墙是由某些硬件机制创建的。

> 以RISCV为例：CSR寄存器组和CSR指令（CSR：Control and Status Registers）。

## 提问：既然内核可以用某些硬件机制建墙，那用户岂不是也可以用它来拆墙？
### 通俗版解答
- 机器上电，操作系统先来，先建好墙，完事了把拆墙工具收到墙内。
- 用户想要拆墙，就要先进到墙内；
- 想要进到墙内，就要先拆墙。

> 以RISCV为例：
> 想要从U模式变到M模式，就必须使用CSR指令修改CSR寄存器组；
> 想要使用CSR指令修改CSR寄存器组，就必须已经处于M模式，否则机器报异常。

### 学术版解答
- 用时间的不可逆性来建构空间的各项异性；
- 互为必要条件。