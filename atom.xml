<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Enchanted to Meet U</title>
  
  
  <link href="https://enchantedovo.cn/atom.xml" rel="self"/>
  
  <link href="https://enchantedovo.cn/"/>
  <updated>2022-10-03T12:06:16.596Z</updated>
  <id>https://enchantedovo.cn/</id>
  
  <author>
    <name>HattieHD</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AdvancedAI-LearningNotes3</title>
    <link href="https://enchantedovo.cn/2022/10/03/AdvancedAI-LearningNotes4/"/>
    <id>https://enchantedovo.cn/2022/10/03/AdvancedAI-LearningNotes4/</id>
    <published>2022-10-03T06:58:20.000Z</published>
    <updated>2022-10-03T12:06:16.596Z</updated>
    
    <content type="html"><![CDATA[<p>占坑</p><h1>一、玻尔兹曼机系列</h1><h2 id="Hopfield">Hopfield</h2><p>Hopfield网络是反馈类型，其神经元的结构功能在网络中的地位是一样的。其学习是基于灌输式学习，即网络的权值不是通过训练出来的，而是按照一定规则计算出来的，<strong>将求解的问题转换成优化问题的能量函数，网络的稳定状态是优化问题的解，其权值一旦确定就不再改变了</strong>。</p><p>简单的来讲就是，Hopfield网络的主要功能是联想记忆。既然如此，首先应该让网络实现“记忆”，我们需要一些数据，然后训练网络，训完练完成之后，可以得到一组可用的权值信息，形成网络的“记忆”功能。当输入数据不完整时，根据训练得到的权重去运算，得到一个稳定的输出状态，这就是联想功能。</p><p>【BM与Hopfield有一定共性，看一下有助理解。】</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/10/03/AdvancedAI-LearningNotes4/p1.png" class title="p1"><h2 id="BM（玻尔兹曼机）">BM（玻尔兹曼机）</h2><p>离散Hopfield神经网络+模拟退火+隐单元=Boltzman机</p><p>Boltzmann机结合多层前馈神经网络和离散Hopfield网络在网络结构、学习算法和动态运行机制方面的优点。它是建立在离散Hopfield网基础上的，具有学习能力，它在神经元状态变化中引入了统计概率，网络的平衡状态服从Boltzmann分布，能够通过一个模拟退火过程寻求最优解。不过，其训练时间比BP网络要长。</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/10/03/AdvancedAI-LearningNotes4/p3.png" class title="p3"><p>原理：<br>1.上文提到Hopfield神经元的结构功能在网络中的地位是一样的,BM中一部分神经元与外部相连接，可以起到网络的输入输出作用，或者严格的说可以受到外部条件的约束，另一部分神经元不与外部相连，因而属于隐单元（相对于外部）。<br>2.每个神经元只有1/0两个状态：状态为1代表神经元处于激活(连接)状态，0表示非激活（断开）状态。</p><h2 id="RBM（受限玻尔兹曼机）">RBM（受限玻尔兹曼机）</h2><p>RBM是BM的一个变体，层间全连接，层内无连接，网络中的神经元是随机神经元。限定模型必须为二分图，学习的目标是极大似然。</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/10/03/AdvancedAI-LearningNotes4/p2.png" class title="p2"><h2 id="DBN（深度置信网络）">DBN（深度置信网络）</h2><p>DBN模型由若干个RBM堆叠而成，通过非监督的预学习和监督微调训练参数。<br>训练时通过从底到高逐层训练这些RBM来实现：</p><p>1.底部RBM以原始输入数据训练；<br>2.将底部RBM抽取的特征作为顶部RBM的输入训练；<br>3.过程（1）和（2）可以重复训练所需的尽可能多的参数。</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/10/03/AdvancedAI-LearningNotes4/p4.png" class title="p4"><h1>CNN卷积神经网络</h1><p>（三、GAN对抗网络）<br>四、RNN及其变种<br>RNN<br>LSTM<br>GRU<br>BRNN<br>DRNNs</p>]]></content>
    
    
    <summary type="html">国科大《高级人工智能》笔记3 —— 深度学习</summary>
    
    
    
    <category term="高级人工智能学习笔记" scheme="https://enchantedovo.cn/categories/%E9%AB%98%E7%BA%A7%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="人工智能" scheme="https://enchantedovo.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>搜索算法</title>
    <link href="https://enchantedovo.cn/2022/10/03/AdvancedAI-LearningNotes2/"/>
    <id>https://enchantedovo.cn/2022/10/03/AdvancedAI-LearningNotes2/</id>
    <published>2022-10-03T06:12:20.000Z</published>
    <updated>2022-10-03T09:54:12.124Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>内容杂且多，老师讲的也一言难尽，用的吴恩达的PPT，也没有用全，跳着讲，公式也不解释清楚变量，推导也不推，照着ppt念，太难了QAQ<br>这里仅记录较为重要的部分</p></blockquote><h1>一些概念</h1><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/10/03/AdvancedAI-LearningNotes2/p1.png" class title="p1"> <h1>无信息搜索</h1><p>无信息搜索也被称为盲目搜索，意味着该搜索策略没有超出问题定义提供的状态之外的附加信息。所有能做的就是生成后继节点。</p><h2 id="深度优先搜索DFS">深度优先搜索DFS</h2><p><strong>描述</strong>：每一次将深度最深的那个节点进行优先探索，若不是终点，则将其拓展并将它的子节点纳入边缘空间，若是边缘空间中所有的节点都是同一个深度，那么就探索最左边的那个节点<br><strong>优点</strong>：机器每次只需要探索最深的那个点，而且边缘空间中的节点也不会太多，不会占用太多的内存<br><strong>缺点</strong>：无法保证完备性和最优性，比较耗费时间</p><h2 id="广度优先搜索BFS">广度优先搜索BFS</h2><p><strong>描述</strong>：与深度搜索不同的是它每次拓展的是边缘空间节点中最浅的那个节点，都是同一个深度的话就拓展最左边的那个节点<br><strong>优点</strong>：具备完备性<br><strong>缺点</strong>：占用内存，而且也不具备最优性</p><h2 id="DFS和BFS比较">DFS和BFS比较</h2><h2 id="迭代深入搜索">迭代深入搜索</h2><p><strong>特点</strong>：同时结合深度优先于广度优先的优点<br><strong>描述</strong>：预先设定一个探索的层数，然后在这个层数以内采用深度优先算法，当在这个层数里面都没有找到终点的话，然后就对这个层数进行拓展，允许进行更深一层的探索<br><strong>优点</strong>：结合FDFS空间优势+BFS时间优势<br><strong>缺点</strong>：可能会造成一定的浪费冗余</p><h2 id="代价敏感搜索">代价敏感搜索</h2><p><strong>特点</strong>：算法开始关注了路程中的代价问题，两个节点之间的代价不再等效处理</p><h2 id="代价一致搜索">代价一致搜索</h2><p><strong>特点</strong>：代价敏感搜索的一种，一致代价搜索总是扩展路径消耗最小的节点N。N点的路径消耗等于前一节点N-1的路径消耗加上N-1到N节点的路径消耗</p><h1>启发式搜索</h1><p>启发式：对每个状态估计到最近目标的距离</p><h2 id="贪婪搜索">贪婪搜索</h2><p><strong>策略</strong>：扩展你认为最接近目标状态的节点，只使用启发函数来评价节点<br><strong>缺点</strong>：只考虑了后半段的距离而没有考虑前面的距离，不能满足最优性</p><h2 id="A-算法（重要）">A*算法（重要）</h2><h2 id="算法介绍">算法介绍</h2><p><strong>特点</strong>：结合贪婪搜索与代价一致搜索<br><strong>策略</strong>：将代价函数g(n)与启发函数h(n)简单相加，得到一个新的函数f(n)，这个函数就是A*算法判断路径的标准<br><strong>估价函数</strong>：f(n)=g(n)+h(n)，其中：g(n)是到达n节点已花费的代价；f(n)是当前节点到目标节点最小代价路径的估计值（greedy）<br><strong>存在问题</strong>：当启发函数h大于实际耗散时，启发函数失效</p><h3 id="可采纳性">可采纳性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 ≤ h(n)≤ h*(n)</span><br></pre></td></tr></table></figure><p>其中：h*(n) 是从 n 结点到目标结点的最优路径的真实代价，当启发式函数 h(n) 满足以上不等式的时候，我们称该 h(n) 是可采纳的 (admissible) ，即：没有过高估计某点到目标点的花费。</p><h3 id="mark-证明A-树搜索的最优性（重要）-mark"><mark>证明A* 树搜索的最优性（重要）</mark></h3><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/10/03/AdvancedAI-LearningNotes2/p2.png" class title="p2"> <h3 id="A-算法其他性质">A*算法其他性质</h3><p>Open表中任一具有f(n)&lt;=f*(S0)的节点n，都被A*算法作为扩展节点</p><h3 id="最优条件">最优条件</h3><ul><li>树A*算法最优条件：可采纳性（h(n)&lt;=h*(n)）</li><li>图A*算法最优条件：一致性（f(n)沿着路径非递减）</li></ul><h2 id="A-图搜索">A*图搜索</h2><h3 id="主要思想">主要思想</h3><p>可采纳性：h(A)&lt;=h*(A)真实<br>一致性：沿路径的节点f(n)值单调递增   h(A)&lt;=cost(A to C)+h©</p><h3 id="最优性">最优性</h3><h4 id="条件">条件</h4><p>一致性：</p><ul><li>A*算法扩展节点，f值单调增</li><li>对于每个状态S，到达S最优的节点先于次优的节点扩展</li></ul><h4 id="证明">证明</h4><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/10/03/AdvancedAI-LearningNotes2/p3.png" class title="p3"> <h2 id="mark-传教士和野人问题的A-搜索-mark"><mark>传教士和野人问题的A*搜索</mark></h2><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/10/03/AdvancedAI-LearningNotes2/p4.png" class title="p4"><p><strong>变量解释</strong>：<br>M-左岸传教士数目<br>C-左岸野人数目<br>B-左岸是否有船<br>Pcm-有c个传教士，m个野人从左岸到右岸<br>Qcm-有c个传教士，m个野人从右岸到左岸</p><p><strong>问题有解所必须的特性</strong></p><ul><li>M&gt;=C且（3-M)&gt;=(3-C)&lt;==&gt;M=C</li><li>或者M=0,M=3</li></ul><p><strong>安全状态(以左岸为例)</strong>：</p><ul><li>传教士与野人的数目相等；</li><li>传教士都在左岸；</li><li>传教士都不在左岸。</li></ul><p><strong>完全状态图</strong>：<br>（不满足约束的不在图内）</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/10/03/AdvancedAI-LearningNotes2/p5.png" class title="p5"><blockquote><p>参考: <a href="https://blog.csdn.net/qq_41296039/article/details/122442921?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_41296039/article/details/122442921?spm=1001.2014.3001.5501</a></p></blockquote><h1>局部搜索</h1><p>爬山法：任意位置开始，可能是局部最优解；<br>模拟退火搜索：引入随机因素，避免局部极大；<br>遗传算法：适应度函数，每步保留N个最好状态。</p><h1>其他</h1><ul><li>未知梯度时，用蚁群算法/粒子群算法；</li><li>贪婪最优搜索不是完备的。</li></ul>]]></content>
    
    
    <summary type="html">国科大《高级人工智能》笔记2 —— 搜索算法</summary>
    
    
    
    <category term="高级人工智能学习笔记" scheme="https://enchantedovo.cn/categories/%E9%AB%98%E7%BA%A7%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="人工智能" scheme="https://enchantedovo.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>人工神经网络</title>
    <link href="https://enchantedovo.cn/2022/10/03/AdvancedAI-LearningNotes3/"/>
    <id>https://enchantedovo.cn/2022/10/03/AdvancedAI-LearningNotes3/</id>
    <published>2022-10-03T02:26:08.000Z</published>
    <updated>2022-10-03T11:27:23.461Z</updated>
    
    <content type="html"><![CDATA[<h1>标题一</h1><p>占坑</p><h2 id="标题二">标题二</h2><!--  -->]]></content>
    
    
    <summary type="html">国科大《高级人工智能》笔记2 —— 人工神经网络</summary>
    
    
    
    <category term="高级人工智能学习笔记" scheme="https://enchantedovo.cn/categories/%E9%AB%98%E7%BA%A7%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="人工智能" scheme="https://enchantedovo.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>设备环境初始化及激活进程0</title>
    <link href="https://enchantedovo.cn/2022/10/01/OS-LearningNotes4/"/>
    <id>https://enchantedovo.cn/2022/10/01/OS-LearningNotes4/</id>
    <published>2022-10-01T09:23:32.000Z</published>
    <updated>2022-10-02T11:53:35.271Z</updated>
    
    <content type="html"><![CDATA[<h1>引言</h1><h2 id="设置根设备、硬盘">设置根设备、硬盘</h2><p>用<code>bootsect.s</code>中写入机器系统数据的信息设置软盘为根设备，并设置内核中的硬盘信息。</p><h2 id="规划物理内存格局">规划物理内存格局</h2><p>设置内存中除内核代码和数据之外三部分的位置和大小：</p><ul><li>主内存区：进程代码运行的空间；</li><li>缓冲区：主机与外设（块设备）交换数据的中转站；</li><li>虚拟盘区：可选，可将外设数据先复制至虚拟盘区，然后加以使用。</li></ul><blockquote><p>注：&lt;&lt;12或&gt;&gt;12相当于乘或除以4KB——页</p></blockquote><h2 id="设置虚拟盘空间并初始化">设置虚拟盘空间并初始化</h2><p>设定内存16MB，虚拟盘2MB（缓冲区末端2MB设为虚拟盘）。调用<code>rd_init()</code>函数，对虚拟盘设置：<br>将虚拟盘请求项处理函数<code>do_rd_request</code>与 请求项处理函数控制结构<code>blk_dev[7]</code>第二项挂钩，意味着内核能通过调用<code>do_rd_request</code>函数处理与虚拟盘相关的请求项操作。</p><h2 id="内存管理结构-mem-map-初始化">内存管理结构 mem_map 初始化</h2><p>调用<code>mem_init()</code>函数，通过<code>mem_map[]</code>对 1MB (内核所在区域)以上的内存分页进行管理，记录一个页面的使用次数</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/10/01/OS-LearningNotes4/p1.png" class title="p1"><h2 id="异常处理类中断服务程序挂接">异常处理类中断服务程序挂接</h2><p><code>trap_init()</code>函数将中断、异常处理的服务程序与IDT进行挂接，逐步重建中断服务体系。</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/10/01/OS-LearningNotes4/p2.png" class title="p2"><p>其中，还需要拼接中断描述符：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/10/01/OS-LearningNotes4/p3.png" class title="p3"><h2 id="初始化块设备请求项结构">初始化块设备请求项结构</h2><p>linux外设分为块设备（硬盘、软盘）和字符设备（键盘、黑屏命令行显示器），进程想与块设备进行沟通，必须经过主机内存的缓冲区。<br>请求项管理结构<code>request[32]</code>就是操作系统管理缓冲区与块设备逻辑块读写关系的数据结构。操作系统决定缓冲块与块设备间的读写操作，并把需要操作的缓冲块记录在请求项中，得到读写块设备操作指令后，只根据请求项中的记录决定要处理哪个设备的哪个逻辑块。</p><p>初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request[i].dev&#x3D;-1; &#x2F;&#x2F;请求项未对应哪个设备</span><br><span class="line">request[i].next&#x3D;NULL; &#x2F;&#x2F;还未形成请求项队列</span><br></pre></td></tr></table></figure><h2 id="与人机交互界面相关外设中断服务程序挂接">与人机交互界面相关外设中断服务程序挂接</h2><p>对串行口、显示器、键盘、开机启动时间设置，以及与此相关的中断服务程序与IDT挂接。</p><h2 id="初始化0进程（重要）">初始化0进程（重要）</h2><p>大致过程如下，都由<code>sched_init()</code>函数实现：</p><ol><li>初始化进程0<ul><li>将进程0的task_struct中LDT、TSS与GDT挂接</li><li>初始化GDT、task[64]以及与进程调度相关寄存器</li></ul></li><li>时钟中断设置 —&gt; 多进程轮转</li><li>系统调用：通过set_system_gate将system_call与IDT挂接（特权3，set_trap_gate为特权0）</li></ol><h3 id="初始化进程0">初始化进程0</h3><p>首先在GDT中初始化进程0所占的4、5项，即初始化TSS0（任务状态段）和LDT0（局部描述符）。</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/10/01/OS-LearningNotes4/p4.png" class title="p4"><p>另外，需要拼接对应的段描述符：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/10/01/OS-LearningNotes4/p5.png" class title="p5"><p>然后还需要通过INIT_TASK指针初始化进程0的task_struct（内核栈）。每个进程都有自己的用户栈和内核栈（跑内核代码时用这个）。</p><h3 id="设置时钟中断">设置时钟中断</h3><p>时钟中断是进程0及其他由它创建的进程轮转的基础。</p><h3 id="设置系统调用总入口">设置系统调用总入口</h3><p>将系统调用函数 system_call 与 int 0x80 中断描述符表挂接。</p>]]></content>
    
    
    <summary type="html">国科大杨力祥《操作系统高级教程》课堂笔记4 —— 设备环境初始化及激活进程0</summary>
    
    
    
    <category term="操作系统高级教程学习笔记" scheme="https://enchantedovo.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="操作系统" scheme="https://enchantedovo.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux Kernel" scheme="https://enchantedovo.cn/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>补充知识整理</title>
    <link href="https://enchantedovo.cn/2022/09/20/OS-LearningNotes3/"/>
    <id>https://enchantedovo.cn/2022/09/20/OS-LearningNotes3/</id>
    <published>2022-09-20T13:07:17.000Z</published>
    <updated>2022-10-02T11:35:07.059Z</updated>
    
    <content type="html"><![CDATA[<h1>分段和分页</h1><blockquote><p>起因是上《操作系统高级教程》时，突然发现对这块的知识已经混沌了，所以重新总结下。<br>参考：<br><a href="https://blog.csdn.net/yzy1103203312/article/details/78529067">https://blog.csdn.net/yzy1103203312/article/details/78529067</a><br><a href="https://blog.csdn.net/qq_32740495/article/details/102924136">https://blog.csdn.net/qq_32740495/article/details/102924136</a></p></blockquote><h2 id="为何需要分段">为何需要分段</h2><p>在8086处理器诞生之前，内存寻址方式就是直接访问物理地址（实模式）。8086处理器为了寻址1M的内存空间，把<strong>地址总线扩展到了20位</strong>。但是，ALU的宽度只有16位，即ALU不能计算20位的地址。为了解决这个问题，从而引入了<strong>分段机制</strong>。</p><h2 id="IA32框架的内存寻址">IA32框架的内存寻址</h2><h3 id="三类地址">三类地址</h3><p>IA32的三类地址如下：</p><ul><li><strong>逻辑地址</strong>：<strong>机器语言指令</strong>用这类地址指定<strong>一个操作数的地址或一条指令的地址</strong>，最原始的地址就是逻辑地址。</li><li><strong>线性地址</strong>：将逻辑地址经过<strong>分段机制转换</strong>之后，便得到了线性地址，每个线性地址都<strong>由一个段基址和段内偏移量组成</strong>。</li><li><strong>物理地址</strong>：线性地址<strong>经过分页单元的处理</strong>之后得到一个实际物理地址，也就是<strong>内存单元的实际地址</strong>，用于芯片级内存单元寻址。</li></ul><blockquote><p><strong>地址空间</strong>：操作系统给每个进程用的一段连续的虚拟内存空间。这个地址范围不是真实的，是虚拟地址的范围，有时甚至会超过实际物理内存的大小。</p></blockquote><h3 id="三类地址的转化">三类地址的转化</h3><p>以上3类地址通过MMU（内存管理单元）来进行转换。其中MMU处理时包含2个过程，分段和分页。在这里简单的说明下具体过程：</p><ol><li>当一条<strong>机器指令</strong>给出一个地址时，这时候的地址便是<strong>逻辑地址</strong>；</li><li>为了得到线性地址，需要从相应的段寄存器中取出16位的段标识符（段选择符），通过这个段标识符可以得到一个段基址。然后将得到的<strong>段基址与指令中的地址相加</strong>，从而得到一个<strong>线性地址</strong>；</li><li>有了线性地址之后，再通过<strong>分页单元</strong>得到<strong>实际的物理地址</strong>。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/76d5c9e629654292b413216ab1ed2c4a.png" alt="在这里插入图片描述"></li></ol><h2 id="分段">分段</h2><h3 id="硬件中的分段">硬件中的分段</h3><p>段是虚拟地址空间的基本单位，分段机制必须把虚拟地址空间的一个地址转换为线性地址空间的一个线性地址。<br>为了实现这种映射，仅仅用段寄存器来确定一个基地址是不够的，至少还得描述段的长度，并且还需要段的一些其他信息，比如访问权之类。所以，这里需要的是一个数据结构——段描述符，它包括三个方面的内容：</p><ul><li>段的基地址(Base Address)：在线性地址空间中段的起始地址。</li><li>段的界限(Limit)：在虚拟地址空间中，段内可以使用的最大偏移量。</li><li>段的保护属性(Attribute)：表示段的特性。例如，该段是否可被读出或写入，或者该段是否作为一个程序来执行，以及段的特权级等等。</li></ul><p>多个段描述符组成的表称为段描述符表。</p><p>逻辑地址的段寄存器中的值提供<strong>段描述符</strong>，然后从段描述符中得到<strong>段基址</strong>和<strong>段界限</strong>，然后<strong>加上逻辑地址的偏移量</strong>，就得到了线性地址，线性地址通过分页机制得到物理地址。</p><h3 id="Linux的分段">Linux的分段</h3><p>为了支持分段，8086处理器设置了四个段寄存器：CS, DS, SS, ES。每个段寄存器都是16位的，都包含着相应段的基址。访存指令中的地址也是16位的，但是，在送入地址总线之前，CPU先把它与某个段寄存器内的值按以下方式相加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际物理地址 &#x3D; （段寄存器地址 &lt;&lt; 4） + （指令访存地址）</span><br></pre></td></tr></table></figure><p>这四个段寄存器的段首地址均是0，也就是说，段首地址+逻辑地址=线性地址，这个公式里面的段首地址为0，也就意味着在linux中，<strong>逻辑地址=线性地址</strong>，这就是linux的分段技术。</p><h2 id="分页">分页</h2><p>对于物理内存，分页单元把它分为固定长度的页框（page frame），每一个页框包含一个页（page）。对于虚拟地址空间，也把它分为一个个的页。为了访问每一个物理页，需要有一个页表，记录每个物理页的起始地址，简单说通过页表就可以将一个虚拟内存中的页与具体的物理页一一对应起来。虚拟地址可以分为两部分，页号和页内偏移，页号为页表的索引，得到页的基地址后，加上偏移地址就可以得到具体的物理地址。</p><p>以32位环境为例，<strong>虚拟地址空间为4G</strong>，一般<strong>一页为4KB</strong>，这样4G内存可以分为1M个页，由于<strong>每个页表项需要4个字节</strong>来描述，因此一共需要4M的存储空间，因为每个进程都有自己的页表，所以1个进程就需要4M的存储空间。</p><h1>特权级CPL、DPL和RPL</h1><h2 id="相关概念">相关概念</h2><p>x86 处理器中，提供了4个特权级别：0，1，2，3。数字越小，特权级别越高！一般来说，操作系统是的重要性、可靠性是最高的，需要运行在0特权级；应用程序工作在最上层，来源广泛、可靠性最低，工作在3特权级别。中间的1和2两个特权级别，一般很少使用。这几个个特权级均由两位（bit）组成，可以表示0～3共4个等级。</p><p>在处理器中，有3个相关的术语与特权级密切相关：</p><ul><li>CPL：<strong>当前进程</strong>的权限级别（Current Privilege Level），是当前<strong>正在执行的代码所在的段</strong>的特权级，存在于cs寄存器的低两位。</li><li>RPL: 说明的是<strong>进程对段访问的请求权限</strong>（Request Privilege Level），是对于段选择子而言的，每个段选择子有自己的RPL，它说明的是进程对段访问的请求权限，有点像函数参数。而且<strong>RPL对每个段来说不是固定的</strong>，两次访问同一段时的RPL可以不同。RPL可能会削弱CPL的作用，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样虽然它是0特权，但对该段仍然只有特权为3的访问权限。</li><li>DPL: 存储在段描述符中，规定<strong>访问该段的权限级别</strong>(Descriptor Privilege Level)，每个段的DPL固定。当进程访问一个段时，需要进程特权级检查，一般要求 DPL &gt;= max {CPL, RPL}</li></ul><p>在保护模式下，cpu利用cpl/rpl/dpl对程序的<strong>访问操作</strong>进行特权级检查，数据段和代码段的特权级检查规则有所不同。</p><h2 id="对数据段和堆栈段访问时的特权级控制：">对数据段和堆栈段访问时的特权级控制：</h2><p>要求访问数据段或堆栈段的程序的CPL ≤ 待访问的数据段或堆栈段的DPL，同时选择子的 RPL ≤ 待访问的数据段或堆栈段的 DPL。即程序访问数据段或堆栈段要遵循一个准则：<strong>只有相同或更高特权级的代码才能访问相应的数据段</strong>。这里，RPL可能会削弱CPL的作用，访问数据段或堆栈段时，默认用CPU和RPL中的最小特权级去访问数据段，所以max {CPL, RPL} ≤ DPL，否则访问失败。</p><h2 id="对代码段访问的特权级控制（代码执行权的特权转移）：">对代码段访问的特权级控制（代码执行权的特权转移）：</h2><p>一些“定律”：</p><ul><li>所有的程序转跳，CPU都不会把段选择子的RPL赋给转跳后程序的CS.RPL.</li><li>转跳后程序的CPL(CS.RPL)只会有下面的2种可能：<ul><li>转跳后程序的CPL(CS.RPL) = 转跳前程序的CPL(CS.RPL)</li><li>转跳后程序的CPL(CS.RPL) =　转跳后程序的CodeDescriptor.DPL</li></ul></li><li>CPU不允许程序向低特权级跳转（认为低特权级的代码不可靠，有风险）</li><li>只有一种方式能够使特权级发生改变，call + 调用门 + 非一致代码段，且当前cpl大于目标段dpl，且特权级只能向上跳转。</li></ul><h1>GDT TSS IDT LDT</h1><h2 id="回顾Linux寻址">回顾Linux寻址</h2><p>Linux中的寻址: logical addr --&gt; linear addr --&gt; physical addr<br>第一个转换是通过GDT的分段机制,第二个转换是通过分页机制。CPU使用logical addr, CPU中的MMU部件使用physical addr。比如一个程序编译后，代码段的指令地址是0x08048888，这就是logical addr，CPU就取这个地址。GDT是一个表，用来实现logical addr–&gt; linear addr的转化，也就是分段思想的实现。gdtr寄存器指向GDT在内存中的首地址，用CS,DS中的内容做为index，这个index的学名叫segment selector。</p><p>CS：在保护模式下的段选择器,我们一直都只把它看做一个段描述符的“索引号”，用来在 GDT (全局描述描述符表) 中查找一个段描述符。<br>用户程序拥有自己私有的描述符表 LDT(Local Descriptor Table),并且拥有自己的特权级别(总不能让用户程序与操作系统一样,工作在非常高的 0 特权级别)。</p><p>正如处理器中有一个寄存器 GDTR，保存着 GDT 的开始地址和长度；处理器中还有一个寄存器 LDTR，存储着当前正在执行的那个应用程序的 LDT 开始地址和长度。</p><h3 id="GDT">GDT</h3><p>在Protected Mode下，对一个段的描述则包括3方面因素：【Base Address, Limit, Access】，它们加在一起被放在一个64-bit长的数据结构中，被称为段描述符。但是，无法通过16-bit长度的段寄存器来直接引用64-bit的段描述符。解决的方法就是把这些长度为64-bit的段描述符放入一个数组中，而将段寄存器中的值作为下标索引来间接引用（事实上，是将段寄存器中的高13 -bit的内容作为索引）。这个全局的数组就是GDT。</p><h3 id="LDT">LDT</h3><p>除了GDT之外，IA-32还允许程序员构建与GDT类似的数据结构，它们被称作LDT（Local Descriptor Table，局部描述符表），但与GDT不同的是，LDT在系统中可以存在多个，并且从LDT的名字可以得知，LDT不是全局可见的，它们只对引用它们的任务可见，每个任务最多可以拥有一个LDT。另外，每一个LDT自身作为一个段存在，它们的段描述符被放在GDT中。</p><p>由于每个进程都有自己的一套程序段、数据段、堆栈段，有了局部描述符表则可以将每个进程的程序段、数据段、堆栈段封装在一起，只要改变LDTR就可以实现对不同进程的段进行访问。</p><h3 id="段选择子是什么？">段选择子是什么？</h3><p>保护模式下，处理器提供段寄存器，处理器提供了6个段寄存器来保存段描述符。这些段寄存器称为cs、ss、ds、es、fs和gs。每个段寄存器都由可见部分和不可见部分组成，当段选择子（可见部分）被加载至段寄存器时，处理器也通过段选择子所指向的段描述符获取了这个段的不可见部分。</p><p>段选择子段选择符为16位，描述段的一些信息，它不是直接指向段，指向在GDT或LDT中的段描述符。它的高13位作为被引用的段描述符在GDT/LDT中的下标索引，bit 2用来指定被引用段描述符被放在GDT中还是到LDT中，bit 0和bit 1是RPL——请求特权等级，被用来做保护目的。</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/20/OS-LearningNotes3/p1.png" class title="p1"><p>段选择子包括三部分：描述符索引（index）、TI、请求特权级（RPL）。它的index（描述符索引）部分表示<strong>所需要的段描述符在描述符表的位置</strong>，由这个位置再根据在GDTR中存储的描述符表基址就可以找到相应的描述符。然后用描述符表中的段基址加上逻辑地址（SEL:OFFSET）的OFFSET就可以转换成线性地址，段选择子中的TI值只有一位0或1，0代表选择子是在GDT选择，1代表选择子是在LDT选择。请求特权级（RPL）则代表选择子的特权级，共有4个特权级（0级、1级、2级、3级）。</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/20/OS-LearningNotes3/p2.png" class title="p2"><h3 id="TSS-任务状态段">TSS: 任务状态段</h3><p>顾名思义，任务状态段就是用来存储和恢复任务的状态信息。</p><p>经常听到一个术语:任务上下文。<br>TSS是一个特殊的段。在Linux中，CPU从系统态切换到用户态时，会用到TSS里面的ss0和esp0。每个CPU只维护一个TSS。TR寄存器指向这个TSS，切换时里面的ss0和esp0会有改变。相应有一个TSSD放在GDT中，是GDT的一个表项。</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/20/OS-LearningNotes3/p3.png" class title="p3"><p>可以看到：任务寄存器中可见部分的段选择符加载TSS描述符的段选择符，访问GDT中TSS描述符，通过TSS描述符访问TSS。同时TSS描述符中的基址和界限字段的值又加载到任务寄存器的不可见部分的基址和界限字段，这样做的目的是下次访问该TSS时可以不用通过GDT中的TSS描述符访问TSS，而是直接通过缓存在任务寄存器中的基址和界限字段访问TSS，加快了系统对TSS的访问。</p>]]></content>
    
    
    <summary type="html">国科大杨力祥《操作系统高级教程》课堂笔记3 —— 补充知识</summary>
    
    
    
    <category term="操作系统高级教程学习笔记" scheme="https://enchantedovo.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="操作系统" scheme="https://enchantedovo.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux Kernel" scheme="https://enchantedovo.cn/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>链路层协议安全</title>
    <link href="https://enchantedovo.cn/2022/09/18/NetProtoSec-LearningNotes3/"/>
    <id>https://enchantedovo.cn/2022/09/18/NetProtoSec-LearningNotes3/</id>
    <published>2022-09-18T09:01:19.000Z</published>
    <updated>2022-10-03T05:58:55.760Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本节分为三个部分：</p><ul><li>有线网络协议安全</li><li>无线网络协议安全</li><li>VLAN安全</li></ul></blockquote><h1>链路层协议安全</h1><h2 id="有线网络协议安全">有线网络协议安全</h2><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/18/NetProtoSec-LearningNotes3/p1.png" class title="p1"><h2 id="无线网络协议安全">无线网络协议安全</h2><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/18/NetProtoSec-LearningNotes3/p2.png" class title="p2"><h2 id="VLAN安全">VLAN安全</h2><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/18/NetProtoSec-LearningNotes3/p3.png" class title="p3"><h3 id="特点">特点</h3><p>VLAN与传统LAN相比，具有以下特点：</p><ul><li>隔离广播域</li><li>创建虚拟工作组，超越传统网络的工作方式，减少改变的代价，安全性⬆，健壮性⬆</li></ul><p>VLAN的划分方法有以下几种：</p><ul><li>基于端口（静态）</li><li>基于MAC（动态）</li><li>基于协议</li><li>基于子网</li></ul><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/18/NetProtoSec-LearningNotes3/p4.png" class title="p4"><h3 id="三层交换机">三层交换机</h3><p>不同VLAN的信息必须通过三层路由处理才能转发到端口上。</p><h4 id="二层交换机与路由器">二层交换机与路由器</h4><p>二层交换机：数据交换靠硬件，但不能处理不同子网(包括VLAN)间数据交换；<br>路由器：主要功能是路由转发，通过软件实现，所以转发效率低。</p><h4 id="三层交换技术">三层交换技术</h4><p>三层交换技术其实就是：二层交换技术+三层转发技术。它能做到<strong>一次路由，多次转发</strong>，对于数据包转发等规律性的过程由硬件高速实现，而像路由信息更新、路由表维护、路由计算等功能，由软件实现。</p><h4 id="工作过程">工作过程</h4><p>1.第一个包过来（包目的MAC是自己，交给IP层，发现IP地址不是自己），硬件转发表无表项，交给路由进程处理，查找下一跳IP，通过ARP得到MAC；<br>2.转发时：修改IP包ttl；修改原mac；建立硬件转发表；<br>3.下一包，直接查看硬件转发表直接转发，而不会经过路由表查询。</p><h3 id="链路类型">链路类型</h3><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/18/NetProtoSec-LearningNotes3/p5.png" class title="p5"><p>1.干道链路<br>可以承载多个不同VLAN数据，用于交换机间、交换机与路由器间的互连，<strong>它不属于任何一个具体VLAN</strong>。所有在干道链路上传输的帧都是打上标记的帧。</p><p>2.接入链路<br>用于连接主机和交换机的链路，接入链路属于某一个特定的端口，这个端口属于一个并且只能是一个VLAN。</p><h3 id="帧在网络通信中的变化">帧在网络通信中的变化</h3><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/18/NetProtoSec-LearningNotes3/p6.png" class title="p6"><h3 id="本征VLAN">本征VLAN</h3><p>相当于默认VLAN，可以在Trunk链路上指定一个Native VLAN。Access端口只属于一个VLAN，所以它的缺省ID就是它所在的VLAN，不用设置；Trunk端口属于多个VLAN， 所以需要设置缺省VLAN ID，缺省情况下为VLAN 1。<br>来自Native VLAN的数据帧通过Trunk链路时不重新封装，以原有的帧传输（不重新打标签）。</p><h3 id="转发原则-由交换机实现">转发原则(由交换机实现)</h3><h4 id="Access-Link">Access-Link</h4><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/18/NetProtoSec-LearningNotes3/p7.png" class title="p7"><h4 id="Trunk-Link">Trunk-Link</h4><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/18/NetProtoSec-LearningNotes3/p8.png" class title="p8"><h3 id="VLAN安全威胁">VLAN安全威胁</h3><h4 id="双标签跳跃攻击">双标签跳跃攻击</h4><p>原理：构造含有双层标签的帧，其外层标记为Trunk链路的 Native VLAN 号，交换机trunk端口发送帧时，将外层标签去掉<br>缺点：只能单项攻击<br>防范：native VLAN设置为一个不存在的VLAN</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/18/NetProtoSec-LearningNotes3/p9.png" class title="p9"><h4 id="DTP跳跃攻击">DTP跳跃攻击</h4><p>DTP：有设备主动向接口发起协议，接口将形成Trunk，该链路可以双向传输任何VLAN数据<br>特点：可双向访问，绕过防火墙</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/18/NetProtoSec-LearningNotes3/p10.png" class title="p10"><h4 id="VPT攻击">VPT攻击</h4><p>原理：VLAN信息的同步是通过VTP通告来实现的， VTP通告只能在Trunk链路上传输（因此交换机之间的Trunk链路必须成功配置了Trunk）<br>思路：攻击者发送高的Revision的VTP通告，就能把网络中的VLAN信息覆盖了</p>]]></content>
    
    
    <summary type="html">国科大《网络协议安全》链路层协议安全学习记录</summary>
    
    
    
    <category term="网络协议安全学习笔记" scheme="https://enchantedovo.cn/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="网络协议" scheme="https://enchantedovo.cn/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="网络安全" scheme="https://enchantedovo.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>网络与系统安全随记</title>
    <link href="https://enchantedovo.cn/2022/09/09/NetSysSec-LearningNotes/"/>
    <id>https://enchantedovo.cn/2022/09/09/NetSysSec-LearningNotes/</id>
    <published>2022-09-09T11:06:26.000Z</published>
    <updated>2022-09-09T13:37:36.281Z</updated>
    
    <content type="html"><![CDATA[<h1>20220909</h1><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/09/NetSysSec-LearningNotes/p1.png" class title="p1"> ]]></content>
    
    
    <summary type="html">网络与系统安全课堂随记</summary>
    
    
    
    <category term="网络与系统安全" scheme="https://enchantedovo.cn/categories/%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="网络与系统安全" scheme="https://enchantedovo.cn/tags/%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>主机和端口扫描</title>
    <link href="https://enchantedovo.cn/2022/09/07/NetProtoSec-LearningNotes2/"/>
    <id>https://enchantedovo.cn/2022/09/07/NetProtoSec-LearningNotes2/</id>
    <published>2022-09-07T11:51:56.000Z</published>
    <updated>2022-09-08T02:49:25.972Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实验环境：Kali+Wireshark+Nmap</p><ul><li>Kali：是一个基于Debian的Linux发行版，预装了许多渗透测试软件，是一个很酷的“黑客操作系统”；</li><li>Wireshark：是一个网络封包分析软件，功能是截取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换；</li><li>Nmap：即Network Mapper，是Linux下的网络扫描和嗅探工具包。</li></ul></blockquote><h1>实验内容</h1><p>1.在Nmap中，使用nmap –sP xx指令实现主机扫描，用wireshark抓取扫描过程中的ARP请求和响应报文；通过ping指令发起ICMP扫描，用wireshark抓取扫描过程中的ICMP报文；</p><p>2.在Nmap中，使用nmap –sS xx指令实现端口扫描，用wireshark抓取扫描过程中的TCP报文。</p><h1>kali网络配置</h1><p>由于我使用的是校园网，因此我这里使用NAT模式。</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/07/NetProtoSec-LearningNotes2/p1.png" class title="p1"> <h2 id="1-查看主机地址">1.查看主机地址</h2><p>首先通过<code>win</code>+<code>R</code>输入cmd打开终端，然后通过<code>ipconfig</code>查看自己主机的ip地址，网关，网段（我这里选择VMnet8）。</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/07/NetProtoSec-LearningNotes2/p2.png" class title="p2"> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IPv4 地址: 192.168.253.1</span><br><span class="line">子网掩码: 255.255.255.0</span><br></pre></td></tr></table></figure><h2 id="2-修改-etc-network-interfaces文件">2.修改/etc/network/interfaces文件</h2><p>然后，通过<code>vim /etc/network/interfaces</code>，设置静态IP：<br>address：把ip地址设置为自己主机网段中的一个，如：我的主机ip是192.168.253.1，这里设为192.168.253.36<br>gateway：在其中加上自己主机的网关，如：192.168.253.2<br>netmask：子网掩码照抄自己主机的，如：255.255.255.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.253.36</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.253.2</span><br></pre></td></tr></table></figure><h2 id="3-修改dns">3.修改dns</h2><p><code>vim /etc/resolv.conf</code>添加几个常用DNS：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">domain localdomain</span><br><span class="line">search localdomain</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 192.168.253.2</span><br></pre></td></tr></table></figure><h2 id="4-重启网络">4.重启网络</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart networking</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;networking restart</span><br></pre></td></tr></table></figure><h2 id="5-测试">5.测试</h2><p>输入<code>ifconfig -a</code>查看ip：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/07/NetProtoSec-LearningNotes2/p3.png" class title="p3"> <h2 id="nmap参数速查">nmap参数速查</h2><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">nmap IP</td><td style="text-align:center">扫描IP</td></tr><tr><td style="text-align:center">nmap -v IP</td><td style="text-align:center">加强扫描</td></tr><tr><td style="text-align:center">nmap IP1 IP2 …</td><td style="text-align:center">扫描多IP</td></tr><tr><td style="text-align:center">nmap a.b.c.*</td><td style="text-align:center">扫描整个子网</td></tr><tr><td style="text-align:center">nmap a.b.c.x,y,…</td><td style="text-align:center">扫描多子网地址</td></tr><tr><td style="text-align:center">nmap -iL xxx.txt</td><td style="text-align:center">根据文件扫描多IP</td></tr><tr><td style="text-align:center">nmap a.b.c.x-y</td><td style="text-align:center">扫描子网IP范围</td></tr><tr><td style="text-align:center">nmap a.b.c.* --exclude IP</td><td style="text-align:center">排除指定IP扫描整个子网</td></tr><tr><td style="text-align:center">nmap -A IP</td><td style="text-align:center">全面的系统扫描,包括操作系统探测、版本探测、脚本扫描、路径跟踪</td></tr><tr><td style="text-align:center">nmap -O IP</td><td style="text-align:center">探测操作系统</td></tr><tr><td style="text-align:center">nmap -sA/-PN IP</td><td style="text-align:center">探测防火墙</td></tr><tr><td style="text-align:center">nmap -sP a.b.c.*</td><td style="text-align:center">探测在线主机</td></tr><tr><td style="text-align:center">nmap -F IP</td><td style="text-align:center">快速扫描</td></tr><tr><td style="text-align:center">nmap -r IP</td><td style="text-align:center">按顺序扫描</td></tr><tr><td style="text-align:center">nmap -iflist</td><td style="text-align:center">显示接口和路由信息</td></tr><tr><td style="text-align:center">nmap -p n1,n2… IP</td><td style="text-align:center">扫描指定端口</td></tr><tr><td style="text-align:center">nmap -p T:n1,n2… IP</td><td style="text-align:center">扫描TCP端口</td></tr><tr><td style="text-align:center">nmap -sU n1,n2… IP</td><td style="text-align:center">扫描UDP端口</td></tr><tr><td style="text-align:center">nmap -sV IP</td><td style="text-align:center">查看服务的版本</td></tr><tr><td style="text-align:center">nmap -PS IP</td><td style="text-align:center">TCP ACK扫描</td></tr><tr><td style="text-align:center">nmap -PA IP</td><td style="text-align:center">TCP SYN扫描</td></tr><tr><td style="text-align:center">nmap -sS IP</td><td style="text-align:center">隐蔽扫描</td></tr><tr><td style="text-align:center">nmap -sN IP</td><td style="text-align:center">TCP空扫描欺骗防火墙</td></tr></tbody></table><h1>主机扫描</h1><blockquote><p>开两个虚拟机：192.168.253.36 + 192.168.253.37</p></blockquote><h2 id="主机扫描参数">主机扫描参数</h2><p>主机发现有时候也叫做ping扫描，有以下选项：<br><code>-sL</code>（列表扫描）：它仅仅列出指定网络上的每台主机，不发送任何报文到目标主机；<br><code>-sP</code>（Ping扫描）：该选项告诉Nmap仅仅进行ping扫描（主机发现），然后打印出对扫描做出响应的那些主机；Nmap会发一个ICMP ECHO请求和一个TCP报文到目标端口；<br><code>-Pn</code>（无ping）：无Ping扫描通常用于防火墙禁止Ping的情况下，完全跳过Nmap发现阶段，且对目标主机进行端口扫描；<br><code>-PS</code>（TCP SYN ping）：该选项发送了一个设置了SYN标志位的空TCP报文，需要root权限；<br><code>-PA</code>（TCP ACK ping）：它与TCP SYN Ping扫描类似，不同的只是设置的TCP报文的标志位是ACK；<br><code>-PU</code>（UDP  ping）：发送一个空的UDP报文到指定端口，很少用；<br><code>-PE/PP/PM</code>（ICMP ECHO/时间戳/地址掩码Ping）；<br><code>-ARP</code>（ARP ping）：该选项通常在扫描局域网时使用，在内网中使用ARP Ping是非常有效的。</p><h2 id="实验过程">实验过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -P 192.168.253.1/24</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/07/NetProtoSec-LearningNotes2/p4.png" class title="p4"> <p>wireshark抓取ARP请求和响应报文：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/07/NetProtoSec-LearningNotes2/p5.png" class title="p5"><p>ping命令发起ICMP扫描，wireshark抓取ICMP报文：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/07/NetProtoSec-LearningNotes2/p6.png" class title="p6"><h1>端口扫描</h1><h2 id="端口扫描基础">端口扫描基础</h2><h3 id="端口状态">端口状态</h3><p>Nmap所识别的6个端口状态：</p><ul><li><code>Opend</code>：端口开启；</li><li><code>Closed</code>： 端口关闭；</li><li><code>Filtered</code>：端口被过滤，数据没有到达主机，返回的结果为空，数据被防火墙拦截了；</li><li><code>Unfiltered</code>：未被过滤，数据有到达主机，但是不能识别端口的当前状态；</li><li><code>Open|filtered</code>：开放或者被过滤，端口没有返回值，主要发生在UDP、IP、FIN、NULL和X mas扫描中；</li><li><code>Closed|filtered</code>：关闭或者被过滤，只发生在IP ID idle扫描。</li></ul><h3 id="命令参数">命令参数</h3><p>-<code>sS</code>（TCP SYN扫描）：半开扫描，很少有系统能把它记入系统日志。不过，需要Root权限；<br>-<code>sT</code>（TCP connect()扫描）:当SYN扫描不能用时，CP Connect()扫描就是默认的TCP扫描；<br>-<code>sN/-sF/-sX</code>（TCP Null/FIN/Xmas扫描）:能躲过一些无状态防火墙和报文过滤路由器；<br>-<code>p</code>：指定范围性扫描端口；<br>-<code>v</code>：详细信息。</p><h2 id="实验过程-2">实验过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─<span class="comment"># nmap -sS 192.168.253.1</span></span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-09-07 22:42 EDT</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.253.1</span><br><span class="line">Host is up (0.00019s latency).</span><br><span class="line">Not shown: 996 filtered tcp ports (no-response)</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">135/tcp  open  msrpc</span><br><span class="line">139/tcp  open  netbios-ssn</span><br><span class="line">445/tcp  open  microsoft-ds</span><br><span class="line">4001/tcp open  newoak</span><br><span class="line">MAC Address: 00:50:56:C0:00:08 (VMware)</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 4.70 seconds</span><br></pre></td></tr></table></figure><p>打开wireshark抓取tcp包，可看到：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/07/NetProtoSec-LearningNotes2/p7.png" class title="p7"><p>扫描主机的135和139端口已经回发数据了。</p>]]></content>
    
    
    <summary type="html">国科大《网络协议安全》实验1 —— 主机和端口扫描</summary>
    
    
    
    <category term="网络协议安全学习笔记" scheme="https://enchantedovo.cn/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="网络安全" scheme="https://enchantedovo.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="Wireshark" scheme="https://enchantedovo.cn/tags/Wireshark/"/>
    
    <category term="Nmap" scheme="https://enchantedovo.cn/tags/Nmap/"/>
    
  </entry>
  
  <entry>
    <title>从开机加电到执行main函数之前的过程</title>
    <link href="https://enchantedovo.cn/2022/09/06/OS-LearningNotes2/"/>
    <id>https://enchantedovo.cn/2022/09/06/OS-LearningNotes2/</id>
    <published>2022-09-06T06:07:10.000Z</published>
    <updated>2022-10-01T09:50:53.600Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考用书：《Linux内核设计的艺术》</p><p>题外话：由于疫情，国科大现在实行线下上网课的形式。本节课就是大家全部到教室，然后老师共享屏幕来教学的，虽然互动减少了，但是还是干货满满。本周主要的笔记是记在电子版书上，下周可能会考虑整个思维导图，或许思路会更清晰。总之，开学前两周，先摸索一下学习方式。</p></blockquote><h1>引言</h1><p>从开机加电到执行main函数之前，主要分为以下三个部分：</p><ol><li>启动BIOS，准备实模式下的中断向量表和中断服务程序</li><li>从启动盘加载操作系统程序到内存：<ul><li>bootsect程序（扇区 -&gt; 主机内存）</li><li>setup程序（设置内核运行所需的机器系统数据）</li><li>head程序（保护模式，内存分页）</li></ul></li><li>为执行32位的main函数做过渡</li></ol><p>整体思维导图：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/06/OS-LearningNotes2/xmind.png" class title="xmind"><h1>启动BIOS</h1><ol><li>CPU的硬件都设置为加电进入实模式</li><li>BIOS程序被固化在ROM中，由<strong>硬件方式</strong>执行：加电瞬间，CS:IP指向BIOS程序的入口地址（0xFFFF0）</li><li>BIOS检测显卡、内存······，并且<strong>在内存中建立中断向量表和中断服务程序</strong></li></ol><blockquote><p>补充知识：</p><ul><li>ROM：只读存储器，断电之后仍能保存信息</li><li>0x00400 = 4*(16^2)字节 = 4*256字节 = 1024字节 = 1KB</li></ul></blockquote><h1>加载操作系统内核程序</h1><h2 id="加载第一部分内核代码——引导程序bootsect">加载第一部分内核代码——引导程序bootsect</h2><p><strong>理解</strong>： bootsect中sect是section的缩写，代表软盘。整个bootsect程序就是<strong>将内核程序从软盘加载到主机内存</strong>的过程。<br><strong>过程</strong>：</p><ol><li>CPU接收到一个int 0x19中断</li><li>对应中断服务程序把软盘中第一扇区的程序（512B）加载到内存的指定位置（0x07C00）</li></ol><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/06/OS-LearningNotes2/p1.png" class title="p1"><blockquote><p>冷知识：0x07C00来自Intel第一台个人电脑8088芯片，为了保持兼容，以后的CPU都保留此地址</p></blockquote><h2 id="加载第二部分内核代码——setup">加载第二部分内核代码——setup</h2><p>BIOS将引导程序bootsect载入内存后，现在需要将第二批、第三批程序陆续加载到内存中。</p><p><strong>1.bootsect对内存的规划</strong><br>为了实现上述操作，bootsect首要工作就是先规划内存。如图，bootsect程序对后续操作涉及的内存位置进行了设置：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/06/OS-LearningNotes2/p2.png" class title="p2"><p><strong>2.复制bootsect</strong><br>接下来，bootsect将自身复制至内存0x90000（INITSEG）处：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/06/OS-LearningNotes2/p3.png" class title="p3"><p><strong>过程</strong>：一遍执行，一边复制<br><strong>目的</strong>：复制完后，就能根据自己的需要规划内存，程序可以执行更复杂的数据运算类指令了</p><p><strong>3.将setup程序加载到内存中</strong><br>通过BIOS提供的int 0x13中断向量指向的中断服务程序，将软盘第二扇区开始的4个扇区（即setup.s对应程序）加载到内存中（SETUPSEG）。</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/06/OS-LearningNotes2/p4.png" class title="p4"><p>此时，操作系统已经从软盘中加载了5个扇区的代码。bootsect程序执行完后，setup程序就要开始工作了。</p><h2 id="加载第三部分内核代码——system模块">加载第三部分内核代码——system模块</h2><p><strong>1.bootsect载入系统模块</strong><br>接下来，bootsect程序进行第三批程序的载入工作。首先，bootsect借助BIOS中断int 0x13，将240个扇区的system<strong>系统模块加载进内存</strong>。至此，整个操作系统的代码已全部加载至内存。bootsect还需要再确认一下根设备号，然后其工作就结束了！</p><blockquote><p>补充：Linux0.11要求系统必须存在一个根文件系统，这里的文件系统☞配套文件系统格式的设备，如一张格式化好的软盘</p></blockquote><p><strong>2.setup程序提取机器系统数据</strong><br>setup程序现在开始执行。首先，它利用BIOS中断服务程序从设备上提取内核所需要运行的机器系统数据（光标位置、显示页面等），并加载在内存中。<br><strong>注意</strong>：BIOS提取的机器系统数据将覆盖bootsect程序所在部分区域，这提高了内存的利用率。<br>到此为止，内核已全部加载完成。接下来，系统将通过已加载到内存的代码，实现<strong>从实模式到保护模式的转变</strong>，使得Linux真正成为“现代”操作系统！</p><h1>向32位模式转变</h1><p>本节，操作系统执行的操作包括打开32位的寻址空间、打开保护模式、建立保护模式下的中断响应机制等与保护模式相关的工作、建立内存分页机制，最后最好调用main函数的准备。</p><h2 id="关闭中断，移动system">关闭中断，移动system</h2><p>首先<strong>关闭中断</strong>，即将CPU的标志寄存器（EFLAGS）的中断允许标志（IF）置0。</p><blockquote><p>补充：</p><ul><li>EFLAGS相当于总开关</li><li>这里的关闭中断并不意味着没有中断了，其实是仍会存在中断，只是不再响应处理而已</li></ul></blockquote><p>接下来，setup程序<strong>将位于0x10000的内核程序复制至内存起始地址0x00000处</strong>，将BIOS中断向量表和BIOS数据区完全覆盖。</p><h2 id="设置中断描述符表和全集描述符表">设置中断描述符表和全集描述符表</h2><p>setup程序<strong>对中断描述符表寄存器（IDTR）和全局描述符表寄存器（GDTR）进行初始化设置</strong>。</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/06/OS-LearningNotes2/p5.png" class title="p5"><blockquote><p>补充知识：<br>GDT：全局描述符表，是存放段寄存器内容（段描述符）的数组，可以理解为进程总目录表<br>GDTR：GDT基地址寄存器，是GDT的入口<br>IDT：中断描述符表，保护模式下所有中断服务程序的入口地址，相当于实模式下的中断向量表<br>IDTR：IDT基地址寄存器，是IDT的入口</p></blockquote><h2 id="打开A20，实现32位寻址">打开A20，实现32位寻址</h2><blockquote><p>寻址：CPU能使用多大空间的内存</p></blockquote><p>打开A20，意味CPU可以进行32位寻址，最大寻址空间为4GB，内存条范围由0~0xFFFFF扩展为0~0xFFFFFFFF。</p><blockquote><p>2^32 = 4*2^30 = 4GB；2^32 = 16^8 = 0xFFFFFFFF</p></blockquote><h2 id="为保护模式下执行head-s做准备">为保护模式下执行head.s做准备</h2><p><strong>1.setup程序对可编程中断控制器重新编程</strong><br>若不对其重新编程，一些Intel保留作为内部的中断和异常中断将被覆盖。</p><p><strong>2.设置CPU为保护模式</strong><br>setup程序将CR0寄存器第0位(PE)置1，即设置CPU为保护模式。</p><p><strong>3.跳转到head程序</strong><br>通过<code>jmpi  0, 8</code>，从setup跳转到head程序。需要把这里的<code>8</code>看成二进制<code>1000</code>：</p><ul><li>0:段内偏移</li><li>8:段选择符<ul><li>二进制1000<ul><li>最后两位(00)：内核特权级<ul><li>倒第三位(0)：代表GDT</li><li>第一位(1)：GDT项号为第2项(从0开始)</li></ul></li></ul></li></ul></li></ul><h2 id="head-s开始执行">head.s开始执行</h2><h3 id="执行过程的整体策略">执行过程的整体策略</h3><p><strong>1.head程序的加载</strong><br>head.s先汇编成目标代码，c语言内核程序编译成目标代码，然后链接成system模块。</p><p><strong>2.head程序创建了内核分页机制</strong><br>在0x000000创建页目录表、页表、页表缓冲区、GDT、IDT，并将head执行完的代码所占内存空间覆盖。这也意味着head将自己废弃，main函数开始执行。</p><h3 id="步骤">步骤</h3><p>1._pg_dir标识内核分页机制完成后的内核起始位置，head程序从这里建立页目录表，为分页机制做准备。<br>2.head正式执行，将CS的用法转为保护模式（CS作为代码段选择符），<code>jump 0,8</code>使CS和GDT第2项关联，并使代码段基址指向0x000000。<br>3.段选择子指向内核代码段：DS、ES、FS和GS（都是段选择子）的值都置为<code>0x10</code>，这里的<code>0x10</code>也看成二进制<code>00010000</code>，其中：</p><ul><li>最后两位（00）：内存特权级；</li><li>倒数第三位（0）：代表GDT；</li><li>第4、5位两位（10）：GDT的2项（从0开始），即第3项。</li></ul><p>（<strong>重要：理解每一位代表的东西</strong>）</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/06/OS-LearningNotes2/p6.png" class title="p6"><p>4.对栈的设置：SS转为栈段选择符，栈顶指针成为32位的esp。</p><blockquote><p>注意：栈顶增长方向由高地址向低地址</p></blockquote><p>5.设置IDT：先让所有中断描述符默认指向ignore_int这个位置，然后对IDT寄存器的值进行设置。</p><ul><li>IDT的一部分 ——&gt; GDT表项 ——&gt; 基址</li><li>另一部分 —解析—&gt;偏移+特权等信息</li></ul><p>6.废除已有的GDT，并在内核新位置重建 ——&gt; 段限长增加了一倍，变为16MB。这里再次对一些段选择符进行重新设置，包括DS、ES等。</p><p>7.检验A20地址线、数学协处理器。</p><p>8.将L6标号和main函数入口地址压栈，栈顶位main函数地址，这使得head执行完，能通过ret直接执行main函数。</p><p>9.创建<strong>分页机制</strong>：<br>首先，将页目录表和4个页表放在物理内存起始位置，此步骤覆盖了head程序自身内存空间（注意：这4个页表都是内核专属页表，将来每个用户进程都有他们的专属页表）。然后，设置页目录表的前4项，分别指向后4个表。然后，将CR3指向页目录表（CR3是物理地址！），启动分页机制开关PG标志置位。然后认定页目录表在内存的起始位置，这个位置是<strong>内核通过分页机制能够实现线性地址等于物理地址</strong>的唯一起始位置。</p><blockquote><p>页目录表、页表都占1页(1 页 4KB，1 项 4B)<br>1 个页表有 1K 项，1 项对应一页覆盖的物理地址(4KB)<br>1 个页目录表覆盖 1K<em>1K</em>4KB = 4GB物理地址</p></blockquote><p>10.ret，通过跳入main函数执行，将压入的main函数在执行入口地址弹出给EIP。</p>]]></content>
    
    
    <summary type="html">国科大杨力祥《操作系统高级教程》课堂笔记2 —— 开机加电后的过程</summary>
    
    
    
    <category term="操作系统高级教程学习笔记" scheme="https://enchantedovo.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="操作系统" scheme="https://enchantedovo.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux Kernel" scheme="https://enchantedovo.cn/tags/Linux-Kernel/"/>
    
    <category term="BIOS" scheme="https://enchantedovo.cn/tags/BIOS/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（课程）导图</title>
    <link href="https://enchantedovo.cn/2022/09/03/ComputerNet-LearningNotes1/"/>
    <id>https://enchantedovo.cn/2022/09/03/ComputerNet-LearningNotes1/</id>
    <published>2022-09-03T06:59:04.000Z</published>
    <updated>2022-09-12T00:52:05.037Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概念性的东西，暂时只做导图</p></blockquote><h1>网络（课程）概述</h1><p>如图：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/03/ComputerNet-LearningNotes1/p1.png" class title="p1"><h1>网络基础：网络模型与直连网络</h1><p>如图：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/03/ComputerNet-LearningNotes1/p2.png" class title="p2">]]></content>
    
    
    <summary type="html">国科大《计算机网络》课程笔记（思维导图）</summary>
    
    
    
    <category term="计算机网络学习笔记" scheme="https://enchantedovo.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://enchantedovo.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络协议安全基础</title>
    <link href="https://enchantedovo.cn/2022/09/01/NetProtoSec-LearningNotes1/"/>
    <id>https://enchantedovo.cn/2022/09/01/NetProtoSec-LearningNotes1/</id>
    <published>2022-09-01T15:16:37.000Z</published>
    <updated>2022-09-07T11:54:32.147Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>知识背景：</p><ul><li>计算机网络</li><li>部分密码学知识<a href="https://www.bilibili.com/video/BV1vq4y1R7Yt?is_story_h5=false&amp;p=1&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=9e54e092-697a-4e52-b1db-99433ded35b8&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;timestamp=1660828486&amp;unique_k=5oAWIQa">密码学教程（P5-P12）</a></li></ul></blockquote><h1>网络协议结构</h1><h2 id="TCP-IP协议">TCP/IP协议</h2><h3 id="局域网LAN与广域网WAN">局域网LAN与广域网WAN</h3><h4 id="LAN">LAN</h4><ul><li>特点：距离小、延迟小</li><li>构建LAN设备：线缆、网卡、集线器（已不用）、交换机、路由器</li></ul><blockquote><p>举例：校园网</p></blockquote><h4 id="WAN">WAN</h4><ul><li>定义：在大范围区域内提供数据通信服务，主要用于互联局域网</li><li>结构：<strong>末端系统</strong>+<strong>通信系统（中间链路）</strong><ul><li><strong>通信系统</strong>工作在<strong>物理层＋数据链路层</strong></li></ul></li><li>交换模式：<ul><li><strong>电路交换</strong>：带宽固定</li><li><strong>分组交换</strong>：多路复用</li></ul></li></ul><h3 id="OSI参考模型">OSI参考模型</h3><h4 id="七层功能">七层功能</h4><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/01/NetProtoSec-LearningNotes1/p1.png" class title="p1"><h4 id="数据通信">数据通信</h4><p>数据通信两个原则：</p><ul><li><strong>对等通信</strong>：每一层使用自己的协议</li><li><strong>数据封装</strong>：封装指网络节点（node）将要传送的<strong>数据用特定的协议头打包</strong></li></ul><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/01/NetProtoSec-LearningNotes1/p2.png" class title="p2"><blockquote><p>提问：为何这里的路由器只画了三层？<br>回答：从端到端通信的角度，路由器不需要工作在4、5层。但是我们需要知道，路由器也有高层协议（RIP/OSFP协议）。</p></blockquote><h3 id="TCP-IP协议栈">TCP/IP协议栈</h3><h4 id="与OSI对应关系">与OSI对应关系</h4><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/01/NetProtoSec-LearningNotes1/p3.png" class title="p3"><h4 id="TCP-IP的封装">TCP/IP的封装</h4><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/01/NetProtoSec-LearningNotes1/p4.png" class title="p4"><h4 id="各层功能">各层功能</h4><ul><li>应用层</li><li>传输层：提供端到端（端口号区分）连接、流量控制（窗口机制）、可靠性（序列号和确认技术实现）<ul><li>TCP：可靠，面向连接<ul><li>三次握手+四次挥手</li></ul></li><li>UDP：无连接通信，可靠性由上层负责</li></ul></li><li>网络层：寻址和路由选择<ul><li>IP协议：IP协议和路由协议协同工作寻找最优路径。不关心报文内容，提供无连接的、不可靠的服务。</li><li>ARP协议：IP协议 -&gt; MAC地址</li><li>ICMP协议：定义了网络层控制和传递消息的功能</li><li>RARP、IGMP</li></ul></li></ul><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/01/NetProtoSec-LearningNotes1/p5.png" class title="p5"><h4 id="思考：手机LTE与电脑WiFi通信？">思考：手机LTE与电脑WiFi通信？</h4><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/01/NetProtoSec-LearningNotes1/p6.png" class title="p6"><ul><li>手机 -&gt; 网关：通过承载网（下面的IP是在承载网上寻址）</li><li>手机网络相当于是一个大二层网络，能够全球通信</li></ul><h2 id="TCP-IP协议族的安全性">TCP/IP协议族的安全性</h2><h3 id="因特网存在的问题">因特网存在的问题</h3><ul><li>资源共享与分组交换<ul><li>IP地址的可见性</li><li>分组交换的方式导致：攻击数据包在被判断恶意前都会被转发到受害者（查找吓下一跳时不会判断是否恶意，容易被DoS攻击）</li></ul></li><li>认证与可追踪性<ul><li>Internet没有认证机制 —&gt; IP欺骗（路由表项只根据目的IP，不会看源IP）</li><li>路由器无数据追踪功能</li></ul></li><li>尽力而为 -&gt; DoS攻击</li><li>匿名与隐私：IP -&gt; 地址，身份 -&gt; ?</li><li>全球网络基础设置不提供可靠性、安全性保证</li></ul><h3 id="设计新的协议栈">设计新的协议栈</h3><ul><li>不能暴露IP</li><li>路由决策</li><li>认证</li><li>路由器可溯源（路由历史记录）</li><li>QoS/流量控制</li><li>身份标识</li></ul><h1>网络协议安全威胁分类</h1><h2 id="网络漏洞分类">网络漏洞分类</h2><ul><li>基于<strong>头部</strong><ul><li>头部某个域使用了无效值</li><li>TCP的FLAG误用攻击</li></ul></li><li>基于<strong>协议</strong><ul><li>不按顺序发送数据包</li><li>发送太快/太慢：DoS攻击</li><li>没发送数据包：SYN雪崩式攻击</li></ul></li><li>基于<strong>验证</strong><ul><li>非法访问接入点</li><li>IPv4地址欺骗</li><li>DNS欺骗</li></ul></li><li>基于<strong>流量</strong><ul><li>雪崩流量：ping一个广播地址</li><li>数据包<strong>嗅探</strong>:DoS攻击</li></ul></li></ul><h2 id="网络层次分类">网络层次分类</h2><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/01/NetProtoSec-LearningNotes1/p7.png" class title="p7">]]></content>
    
    
    <summary type="html">国科大《网络协议安全》课堂笔记1 —— 网络协议安全基础</summary>
    
    
    
    <category term="网络协议安全学习笔记" scheme="https://enchantedovo.cn/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="网络协议" scheme="https://enchantedovo.cn/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="网络安全" scheme="https://enchantedovo.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>人工智能概述</title>
    <link href="https://enchantedovo.cn/2022/09/01/AdvancedAI-LearningNotes1/"/>
    <id>https://enchantedovo.cn/2022/09/01/AdvancedAI-LearningNotes1/</id>
    <published>2022-09-01T15:03:53.000Z</published>
    <updated>2022-09-13T14:49:51.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>三节课讲述的东西太多，这里仅记录相对来说稍重要的部分。</p></blockquote><h1>图灵测试</h1><h2 id="什么是图灵测试">什么是图灵测试</h2><p>测试者与被测试者（一个人和一台机器）隔开的情况下，通过一些装置（如键盘）向被测试者随意提问。进行多次测试后，如果机器让平均每个参与者做出超过30%的误判，那么这台机器就通过了测试，并被认为具有人类智能。</p><blockquote><p>图灵问题：Can Machine Think？（思考）</p></blockquote><h2 id="质疑">质疑</h2><ul><li>图灵测试是不可构造的：“完全不接触”环境难以构建</li><li>图灵测试不可重现的：问题是开放的，答案正确性判断是主观的</li><li>图灵测试无法进行数学分析：只是一种操作式测试，缺少形式化描述</li></ul><h1>人工智能三大学派</h1><h2 id="符号主义">符号主义</h2><ul><li>认为“人的认知基元是符号（语言文字），认知过程即符号操作过程”</li><li>认为人工智能的<strong>核心是知识表示、知识推理和知识运用</strong></li><li>衍生出：逻辑、专家系统、知识库、<strong>知识图谱</strong></li></ul><h2 id="联结主义">联结主义</h2><ul><li>又称<strong>仿生</strong>学派或生理学派</li><li>认为人的思维基元是神经元，而不是符号处理过程</li><li>原理：神经网络及神经网络间的连接机制和学习算法</li><li>衍生出：<strong>人工神经网络</strong>，认知科学、类脑计算</li></ul><h2 id="行为主义">行为主义</h2><ul><li>又称进化主义或<strong>控制论学派</strong></li><li>主张<strong>利用机器对环境作用后的响应或反馈为原型</strong>来实现智能化</li><li>衍生出：动态规划、<strong>强化学习</strong>、多智能体</li></ul><h1>课程蓝图</h1><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2022/09/01/AdvancedAI-LearningNotes1/p.png" class title="p">]]></content>
    
    
    <summary type="html">国科大《高级人工智能》课堂笔记1 —— 人工智能概述</summary>
    
    
    
    <category term="高级人工智能学习笔记" scheme="https://enchantedovo.cn/categories/%E9%AB%98%E7%BA%A7%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="人工智能" scheme="https://enchantedovo.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>操作系统的“公理化”</title>
    <link href="https://enchantedovo.cn/2022/08/30/OS-LearningNotes1/"/>
    <id>https://enchantedovo.cn/2022/08/30/OS-LearningNotes1/</id>
    <published>2022-08-30T07:05:26.000Z</published>
    <updated>2022-09-07T11:54:47.482Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>源码阅读工具：Source Insight</li><li>关键字:<ul><li>内核Kernel</li><li>特权级</li><li>授权</li></ul></li><li>主要内容：本节课主要探讨了Linux内核，老师从逻辑推理的角度带大家体会什么是内核，为什么需要内核。</li></ul></blockquote><h1>授权</h1><h2 id="观点：未经授权，不得访问其他用户的资源">观点：未经授权，不得访问其他用户的资源</h2><blockquote><p>访问自己的资源，总是授权的。</p></blockquote><h2 id="探讨">探讨</h2><h3 id="问题：未经许可，用户是否能访问外设（IO）中自己的资源？">问题：未经许可，用户是否能访问外设（IO）中自己的资源？</h3><ul><li>答案：不可以。</li><li>原因：IO物理端口只有一个，而用户程序具有不确定性（可能会做一些坏事），如果开放端口，可能会无法控制。</li><li>解决办法：若用户非要访问（IO指令/MMIO），则用特权级拦住。<ul><li>特权级：CPU剥夺了应用程序访问外设的能力。</li></ul></li></ul><h3 id="问题：而自己的资源，应该要能访问的，那怎么办？">问题：而自己的资源，应该要能访问的，那怎么办？</h3><ul><li>因为：用户进程是不确定的，并且它应该是不确定的，没有理由要求它确定。</li><li>由<strong>一组确定的程序</strong>来访问自己的资源————即<strong>内核</strong>。</li></ul><h1>特权级</h1><h2 id="特权级的概念">特权级的概念</h2><p>在linux系统中特权级别分为0，1，2，3一共四个级别，0最大 ，3最小。</p><ul><li>一般内核代码运行在0特权级；</li><li>驱动、虚拟机等运行在1，2特权级；</li><li>而我们自己写的程序一般运行在3特权级，也就是最低级别。</li></ul><h2 id="探讨-2">探讨</h2><h3 id="用户程序指令（3特权）为什么不能访问0特权的数据？">用户程序指令（3特权）为什么不能访问0特权的数据？</h3><p>答：因为用户程序指令具有不确定性。</p><h3 id="0特权能否直接跳到3特权？">0特权能否直接跳到3特权？</h3><p>答：不允许，若此时0特权跳转过去后仍保持全态，那么应用程序就会直接变为kernel。</p><h1>接续访问机制</h1><p><strong>接续访问机制</strong>：用户发起 -&gt; 内核接续（IO行为） -&gt; 交付用户</p><h2 id="观点：内核的工作，是用户进程访问行为的延续">观点：内核的工作，是用户进程访问行为的延续</h2><h2 id="观点：内核需要结构化，提供一组自洽的、一致的syscall">观点：内核需要结构化，提供一组自洽的、一致的syscall</h2><h2 id="提问：既然未经授权，不得访问其他用户的资源。那所谓授权，又是给谁的？">提问：既然未经授权，不得访问其他用户的资源。那所谓授权，又是给谁的？</h2><p>思考：</p><ul><li>给用户？同一个用户，有可能可以读A文件，而B文件不行；</li><li>给资源？同一份资源，有可能用户1可以读，而用户2不行。</li></ul><p>答：给&quot;访问&quot;：一般是三元组（用户，操作，资源）。即<strong>一次授权对应一次访问</strong></p><h2 id="提问：从用户发起到内核接续，也即不确定行为到确定行为，如何实现？">提问：从用户发起到内核接续，也即不确定行为到确定行为，如何实现？</h2><p>答：1. 反转状态；2. 要求转移指令确定的落点：（1）限制用户进程的跳转指令；（2）限制用户进程的跳转落点.</p><blockquote><p>补充：以RISC-V为例，（1）只能是ecall指令；（2）只能是mtvec，中断向量基址，该值由OS内核指定。</p></blockquote><h2 id="观点：接续访问机制的重要保障：用户态和内核态之间有面-墙">观点：接续访问机制的重要保障：用户态和内核态之间有面&quot;墙&quot;</h2><p>墙是由某些硬件机制创建的。</p><blockquote><p>以RISCV为例：CSR寄存器组和CSR指令（CSR：Control and Status Registers）。</p></blockquote><h2 id="提问：既然内核可以用某些硬件机制建墙，那用户岂不是也可以用它来拆墙？">提问：既然内核可以用某些硬件机制建墙，那用户岂不是也可以用它来拆墙？</h2><h3 id="通俗版解答">通俗版解答</h3><ul><li>机器上电，操作系统先来，先建好墙，完事了把拆墙工具收到墙内。</li><li>用户想要拆墙，就要先进到墙内；</li><li>想要进到墙内，就要先拆墙。</li></ul><blockquote><p>以RISCV为例：<br>想要从U模式变到M模式，就必须使用CSR指令修改CSR寄存器组；<br>想要使用CSR指令修改CSR寄存器组，就必须已经处于M模式，否则机器报异常。</p></blockquote><h3 id="学术版解答">学术版解答</h3><ul><li>用时间的不可逆性来建构空间的各项异性；</li><li>互为必要条件。</li></ul>]]></content>
    
    
    <summary type="html">国科大杨力祥《操作系统高级教程》课堂笔记1 —— 为什么需要内核</summary>
    
    
    
    <category term="操作系统高级教程学习笔记" scheme="https://enchantedovo.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="操作系统" scheme="https://enchantedovo.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux Kernel" scheme="https://enchantedovo.cn/tags/Linux-Kernel/"/>
    
    <category term="特权级" scheme="https://enchantedovo.cn/tags/%E7%89%B9%E6%9D%83%E7%BA%A7/"/>
    
    <category term="授权" scheme="https://enchantedovo.cn/tags/%E6%8E%88%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>雅思写作Task2</title>
    <link href="https://enchantedovo.cn/2022/08/27/IELTS2/"/>
    <id>https://enchantedovo.cn/2022/08/27/IELTS2/</id>
    <published>2022-08-27T10:45:48.253Z</published>
    <updated>2021-02-16T08:08:58.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大作文基本了解">大作文基本了解</h2><h3 id="得分-时间-要求">得分+时间+要求</h3><p>大作文得分占比2/3，时间约40分钟，要求250字上下</p><h3 id="类型">类型</h3><ul><li>优缺点</li><li>同意不同意</li><li>双边观点</li><li>报告类</li></ul><h2 id="结构layout">结构layout</h2><h3 id="开头">开头</h3><p>开头句由两部分构成：<strong>背景句</strong>+<strong>观点句</strong></p><ol><li><p>背景句改写</p><ul><li>换词</li><li>换主语</li><li>传统现在对比法（也要追求词语和主语的多样性）<ul><li>传统：Traditionally/It is traditional that…</li><li>现在：<ul><li>But now this situation has changed with… - But now it has been suggested that…</li><li>But now it has been encouraged that…</li></ul></li></ul></li></ul><blockquote><p>注意：题目中有两个对比的对象时，可以选择对比法，没有对比的对象时，直接换词、换主语。</p></blockquote></li><li><p>观点句写法</p><ul><li>优缺点，同意不同意：用 although 表明观点</li><li>双边观点：观点 A 和观点 B 矛盾，用 although；不矛盾，用 both and</li><li>报告类：直接回答题目（原因＋措施；原因＋结果；措施＋结果）</li></ul></li></ol><h3 id="中间段">中间段</h3><p>（后面详细讲）</p><h3 id="结尾">结尾</h3><p>（与开头对应）</p><h2 id="开头结尾举例">开头结尾举例</h2><h3 id="优缺点类开头结尾">优缺点类开头结尾</h3><p>In some countries, more and more adults choose to live with their parents after they graduate and find jobs. Do the advantages of this outweigh the disadvantages?</p><h4 id="利弊相等">利弊相等</h4><p>开头：Living with parents has become an increasingly popular choice among young adults who have already graduated and been employed. <u><strong>In my opinion</strong>, this practice has <strong>both</strong> positive <strong>and</strong> negative outcomes. </u></p><p>结尾 ：<strong>Overall</strong>, staying with parents is beneficial to these graduates. <u><strong>However</strong>, it may also lead to some problems that should not be overlooked.</u></p><h4 id="利大于弊">利大于弊</h4><p>开头：Living with parents has become an increasingly popular choice among young adults who have already graduated and been employed. <u><strong>In my opinion</strong>, this practice <strong>has some benefits</strong>, <strong>although</strong> there are some problems that should not be overlooked.</u></p><p>结尾：Overall，staying with parents should be encouraged. <u><strong>While</strong> such a practice may lead to problems, the negative outcomes can be reduced to a minimum by means of effective methods.</u></p><blockquote><p>总之，xxx是应该被鼓励的，虽然xxx会导致一些问题，但是这些后果可以通过一些措施被减轻到最小（the negative outcomes can be reduced to a minimum by means of effective methods）。</p></blockquote><h4 id="弊大于利">弊大于利</h4><p>开头：Living with parents has become an increasingly popular choice among young adults who have already graduated and been employed.<u> <strong>Although</strong> this practice has some benefits, <strong>it may lead to some problems</strong>. </u></p><p>结尾：<u><strong>Overall</strong>，<strong>while</strong> there are some advantages in advocating such a practice, it is not practical for these graduates to stay with their parents.</u></p><h3 id="同意不同意开头结尾">同意不同意开头结尾</h3><p>Schools should stop teaching children with books which students think boring, and use films, TV, video games and computer instead. To what extent do you agree or disagree?（2018.8.18）</p><h4 id="偏向同意">偏向同意</h4><p>开头：<strong>Traditionally</strong>, students are taught through written books. <strong>Nowadays</strong>, different teaching methods like films, video games are suggested to replace the boring books. <u><strong>In my opinion</strong>, I generally agree with the practice, <strong>although</strong> it <strong>may lead to some problems</strong>.</u></p><p>结尾：<u><strong>In conclusion</strong>, replacing paper-based teaching method with media-based one should be encouraged, <strong>although</strong> this practice may have some drawbacks.</u></p><h4 id="偏向不同意">偏向不同意</h4><p>开头：Traditionally, students are taught through written books. Nowadays, different teaching methods like films, video games are suggested to replace the boring books. <u><strong>In my opinion</strong>, I <strong>generally disagree with</strong> the practice, although it has some benefits. </u></p><p>结尾：<u><strong>In conclusion</strong>, <strong>although</strong> replacing paper-based teaching method with media-based one has some benefits, this practice has some drawbacks and should not be encouraged.</u></p><h3 id="双边观点">双边观点</h3><h4 id="两观点矛盾（A-or-B）">两观点矛盾（A or B）</h4><p>Some people think that younger people are not suitable for important positions in governments of countries, while others think that it is a good idea for younger people to take these positions. Discuss both views and give your own opinion.（2017.10.21）</p><p>开头：Leaders or directors in governments are important positions. <strong>People have different views on</strong> whether young people are qualified to such posts. <u><strong>In my opinion</strong>, <strong>Although</strong> this group may have problems in taking these posts, I <strong>would argue that</strong> it is a good choice for them to do so. </u></p><p>结尾：<u><strong>In conclusion</strong>, these young people should be given the equal access to the important positions in governments. <strong>Although</strong> they may be less experienced, this can be addressed effectively by means of related measures.</u></p><h4 id="两观点不矛盾（A-and-B）">两观点不矛盾（A and B）</h4><p>People have different views on how governments reduce traffic congestion. Some think it can be solved by building more trains and subway lines, while others think building more roads and widening existing roads will reduce traffic congestion. Discuss both views and give your own opinion.（2018.7.7）</p><p>开头：In contemporary society, the traffic congestion is becoming increasingly serious. <strong>People have different views on</strong> how to tackle such a pressing problem.<u> <strong>In my opinion</strong>, <strong>both</strong> the development of public transport <strong>and</strong> the construction of roads <strong>are equally important</strong>. </u></p><p>结尾： <u><strong>In conclusion</strong>, <strong>the above mentioned two measures are not mutually exclusive</strong>. They <strong>both</strong> play an significant part in alleviating traffic jam.</u></p><h3 id="报告类">报告类</h3><p>The natural resources such as oil, forests and water are being consumed at an alarming rate. What problems does it cause and how can we solve the problems?（2015.8.1）</p><p>开头：<strong>In recent years</strong>, the depletion of natural resources has become increasingly rapid. <strong>This may lead to serious consequences and it is high time that related measures should be adopted.</strong></p><p>结尾：<strong>Overall</strong>, <strong>the problems are alarmingly pressing</strong>. <strong>However</strong>, <strong>If the above mentioned measures are taken effectively and efficiently, the negative outcomes can be reduced to a minimum.</strong></p><h2 id="中间段结构">中间段结构</h2><h3 id="优缺点-Advantage-or-disadvantage">优缺点 Advantage or disadvantage</h3><h4 id="偏向于好处">偏向于好处</h4><p><strong>偏向于好处</strong>用<strong>起立驳尾</strong></p><h5 id="起"><strong>起</strong></h5><p>Although there may be a problem, I think such a practice is beneficial/should be encouraged.</p><h5 id="立"><strong>立</strong></h5><p>（写一个优点或两个优点都可以）</p><ol><li>优点 1：</li></ol><ul><li>方法一：The obvious argument in favor of sth（sth 是根据题目来，比 如可以是 doing unpaid community service/learning art classes） is that ＋完整的句子（优点 1）<ul><li>Eg：The obvious argument in favor of doing unpaid community service is that students could develop interpersonal skills（优点具体）</li></ul></li><li>方法二：It is true that ＋完整的句子(优点 1)<ul><li>Eg：It is true that doing unpaid community service tends to have a favorable effect on students.（优点抽象）</li></ul></li></ul><ol><li>优点 2：<br>Apart from that，another reason for advocating sth （sth 根据题目来, 比 如可以是 voluntary projects）is that ＋完整的句子（优点 2）</li></ol><ul><li>Eg：Apart from that, another reason for advocating voluntary projects is that students can adapt to the society easily.</li></ul><h5 id="驳"><strong>驳</strong></h5><p>（坏处可以被解决） However, it may be argued that sth is bad for sb. Specifically, ＋缺点. Fortunately, this alarmingly pressing problem could be reduced to a minimum if ＋措施</p><h5 id="尾"><strong>尾</strong></h5><p>In conclusion，sth is beneficial to sb. Although it may have a problem, it could be solved effectively and efficiently by means of related measure.(注意 measure，problem 的单复数)</p><h4 id="偏向于坏处">偏向于坏处</h4><p><strong>偏向于坏处</strong>用<strong>起承转合</strong></p><h5 id="起-2">起</h5><p>Although it may be beneficial, the problems should not be overlooked.</p><h5 id="承">承</h5><p>The obvious argument in favor of sth（sth 是根据题目来，比如可以是 doing unpaid community service/learning art classes） is that ＋完整的 句子（优点）</p><h5 id="转">转</h5><p>However, the problems arising from this practice are far more pressing. The first shortcoming is that＋完整的句子（缺点 1 ）Another drawback is that＋完整的句子（缺点 2）</p><h5 id="合">合</h5><p>In conclusion，sth should not be encouraged，although it is good for sb.</p><h3 id="同意不同意Agree-or-disagree">同意不同意Agree or disagree</h3><p>同样可以用到<strong>起立驳尾</strong>和<strong>起承转合</strong>的结构</p><h4 id="起立驳尾">起立驳尾</h4><p>（把同意的原因立起来，再说不同意，随后反驳不同意）</p><ul><li>Eg：Some people believe that it is a good idea to continue to work at their old age. Do you agree or disagree?<ul><li>起：同意老人持续工作</li><li>立：同意的原因（有经验，对公司好）</li><li>驳：不同意的原因，随后反驳（身体较差，但只要公司合理安排时间，保证老人有足够的休息，坏处就可以避免）</li><li>尾：同意老人持续工作</li></ul></li></ul><h4 id="起承转合">起承转合</h4><p>（先承认同意的原因，再转向不同意）</p><ul><li>Eg: Some said the teachers’ main role is to transmit the information. Nowadays students are exposed to different information, so the role of the teacher will not work in modern education. Do you agree or disagree with this opinion?<ul><li>起：不同意老师会消失</li><li>承：同意的原因（学生可以自学，不需要老师）</li><li>转：不同意的原因（但学生不能辨别网上信息的真假，老师的存在， 可以让老师和学生互动，可以向学生提供帮助）</li><li>合：不同意老师会消失</li></ul></li></ul><h3 id="双边观点-Both-views">双边观点 Both views</h3><ol><li>两观点矛盾，用 A or B 结构</li></ol><ul><li><strong>Introduction</strong>： Although B…, I think A…（偏向于 A）</li><li><strong>Body1</strong>： Some people think that 观点 A 的合理性</li><li><strong>Body2</strong>： However, opponents may make it clear that 先说观点 B 的合理性，再 说观点 B 的不合理性</li><li><strong>Conclusion</strong>：偏向观点 A</li></ul><ol start="2"><li>两观点不矛盾，用 A and B 的结构</li></ol><ul><li><strong>Introduction</strong>： Both A and B</li><li><strong>Body1</strong>： Some people think that 观点 A 的合理性</li><li><strong>Body2</strong>： However, opponents may make it clear that 观点 B 的合理性。</li><li><strong>Conclusion</strong>： Both A and B</li></ul><h3 id="报告类结构">报告类结构</h3><p>Consumption of the world’s resources(such as oil,fresh water,etc) is increasing at a dangerous rate. What are the causes of this increased consumption? What can people do to reduce it?</p><p><strong>Introduction：</strong><br>In recent years, people deplete natural resources rapidly. From my perspective, there are several reasons accountable for this phenomenon and it is high time that related measures should be adopted.</p><p><strong>Body1：</strong><br>First of all, sth is the primary reason.(原因 1)＋Another cause is that（原因 2）</p><p><strong>Body2:</strong><br>Serious as the phenomenon is, there are some effective and efficient measures. One possible method is to（措施 1）. Another solution is to （措施 2）</p><p><strong>Conclusion:</strong><br>Overall the consumption of the world’s resources is undergoing a dangerous rate, however, it is still not too late to settle the problem. With population control and the improvement of the awareness of saving resources, the problem can be effectively addressed.</p><h2 id="论证方法总结">论证方法总结</h2><ol><li>原因：this is because, as, since</li><li>结果: as a result, as a consequence, consequently</li><li>假设：when</li><li>抽象到具体：like, such as</li><li>反面论证: by contrast (最多用一次）</li></ol><p>Eg：The participation in community services helps develop students’ interpersonal skills. This is because they would meet different peers coming from different background. When asked to finish some tasks, like cleaning a library or taking good care of old people, such teenagers may be encountered with some problems. In this case, they are more likely to cooperate with each other with the aim of successfully and effectively solving the problems. As a result, these adolescents could have a better understanding of the importance of team spirit, which helps them to adjust to a wider community easily. By contrast, those who stay away from such free services may find it hard to adapt to the society where cooperation is of great significance.</p>]]></content>
    
    
    <summary type="html">雅思写作学习笔记2——大作文、话题作文</summary>
    
    
    
    <category term="雅思" scheme="https://enchantedovo.cn/categories/%E9%9B%85%E6%80%9D/"/>
    
    
    <category term="雅思写作" scheme="https://enchantedovo.cn/tags/%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/"/>
    
    <category term="英语" scheme="https://enchantedovo.cn/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>LC旋转数组</title>
    <link href="https://enchantedovo.cn/2021/05/20/LC%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>https://enchantedovo.cn/2021/05/20/LC%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</id>
    <published>2021-05-20T15:23:42.000Z</published>
    <updated>2021-05-20T15:38:01.263Z</updated>
    
    <content type="html"><![CDATA[<h1>旋转数组</h1><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><blockquote><p><strong>示例 1:</strong></p><ul><li>输入: nums = [1,2,3,4,5,6,7], k = 3</li><li>输出: [5,6,7,1,2,3,4]</li><li>解释:<ul><li>向右旋转 1 步: [7,1,2,3,4,5,6]</li><li>向右旋转 2 步: [6,7,1,2,3,4,5]</li><li>向右旋转 3 步: [5,6,7,1,2,3,4]</li></ul></li></ul></blockquote><blockquote><p><strong>示例 2:</strong></p><ul><li>输入：nums = [-1,-100,3,99], k = 2</li><li>输出：[3,99,-1,-100]</li><li>解释:<ul><li>向右旋转 1 步: [99,-1,-100,3]</li><li>向右旋转 2 步: [3,99,-1,-100]</li></ul></li></ul></blockquote><h2 id="方法一：傻瓜方法">方法一：傻瓜方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = numsSize;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">list</span>[length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="built_in">list</span>[i]=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">        nums[(j+k)%length]=<span class="built_in">list</span>[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二：旋转旋转旋转">方法二：旋转旋转旋转</h2><p>举个例子：</p><blockquote><p>nums = [1,2,3,4,5,6,7], k = 3</p><ol><li>[7,6,5,4,3,2,1] (整个数组旋转)</li><li>[[5,6,7],[1,2,3,4]]</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先旋转整个数组-》旋转前一部分-》旋转后一部分</span></span><br><span class="line">    k=k%numsSize;</span><br><span class="line">    reverse(nums,<span class="number">0</span>,numsSize<span class="number">-1</span>);</span><br><span class="line">    reverse(nums,<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">    reverse(nums,k,numsSize<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[start];</span><br><span class="line">        nums[start++]=nums[end];</span><br><span class="line">        nums[end--]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥦🐔刷题记录</summary>
    
    
    
    <category term="刷题" scheme="https://enchantedovo.cn/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="LC" scheme="https://enchantedovo.cn/tags/LC/"/>
    
    <category term="数组" scheme="https://enchantedovo.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>PTA习题7-1</title>
    <link href="https://enchantedovo.cn/2021/05/13/PTA%E4%B9%A0%E9%A2%987-1/"/>
    <id>https://enchantedovo.cn/2021/05/13/PTA%E4%B9%A0%E9%A2%987-1/</id>
    <published>2021-05-13T14:38:19.000Z</published>
    <updated>2021-05-13T15:33:11.328Z</updated>
    
    <content type="html"><![CDATA[<h1>7-1 最大子列和问题</h1><p>给定K个整数组成的序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>N</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>N</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>N</mi><mi>k</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\lbrace N_1,N_2,\cdots,N_k \rbrace</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，“连续子列”被定义为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>N</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>N</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>N</mi><mi>j</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\lbrace N_i,N_{i+1},\cdots,N_j \rbrace</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p><p>本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：</p><ul><li>数据1：与样例等价，测试基本正确性；</li><li>数据2：102个随机整数；</li><li>数据3：103个随机整数；</li><li>数据4：104个随机整数；</li><li>数据5：105个随机整数；</li></ul><p>输入格式:<br><code>输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。</code></p><p>输出格式:<br><code>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。</code></p><p>输入样例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">-2 11 -4 13 -5 -2</span><br></pre></td></tr></table></figure><h2 id="解法一：存放在数组中，一个一个来比较">解法一：存放在数组中，一个一个来比较</h2><p>时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,n,max=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//每一趟</span></span><br><span class="line">        <span class="keyword">for</span>(j=i;j&lt;n;j++)&#123;</span><br><span class="line">            sum+=a[j];</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;max)&#123;</span><br><span class="line">                max=sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二：联机实现">解法二：联机实现</h2><p>时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>步骤：</p><ol><li>先进行初始化，max赋0</li><li>再从头开始累加，加到大于最大子序列和的值，把这个值给MaxSum</li><li>如果累加为负数，这一小段的最大子序列就已经出来了，可以重新进行累加比较了</li><li>最后MaxSum一定为最大子序列的和</li></ol><p>这题的关键：只要是首位元素为负数的肯定不是最大子列的组成部分，我们可以将其抛弃。即如果某个子列的首位为负数，那么它一定要借助后面的非负数。所以<strong>如果前面的n项是负数的话，后面的K-n项和一定会比K项和要大，所以在遇到前n项和是负数时，直接将和置0，从n+1项重新开始加</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, maxsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += a[i]; <span class="comment">//依次向右累加</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; maxsum)</span><br><span class="line">            maxsum = sum; <span class="comment">//更新最大值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">            sum = <span class="number">0</span>; <span class="comment">//如果当前和为负数，那么后面的和会减小，所以需要新的起点。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, maxsum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法三：分治法">解法三：分治法</h2><p>首先，我们可以把整个序列平均分成左右两部分，答案则会在以下三种情况中：</p><ol><li>所求序列完全包含在左半部分的序列中。</li><li>所求序列完全包含在右半部分的序列中。</li><li>所求序列刚好横跨分割点，即左右序列各占一部分。</li></ol><p>前两种情况和大问题一样，只是规模小了些，如果三个子问题都能解决，那么答案就是三个结果的最大值。</p><p>我们主要研究一下第<strong>三种情况</strong>如何解决：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/05/13/PTA%E4%B9%A0%E9%A2%987-1/img.png" class title="img"><p>我们只要计算出：以分割点为起点向左的最大连续序列和、以分割点为起点向右的最大连续序列和，这两个结果的和就是第三种情况的答案。因为已知起点，所以这两个结果都能在O(N)的时间复杂度能算出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//N是数组长度，num是待计算的数组，放在全局区是因为可以开很大的数组</span></span><br><span class="line"><span class="keyword">int</span> N, num[<span class="number">16777216</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//序列长度为1时</span></span><br><span class="line">    <span class="keyword">if</span>(left == right)</span><br><span class="line">        <span class="keyword">return</span> num[left];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//划分为两个规模更小的问题</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lans = solve(left, mid);</span><br><span class="line">    <span class="keyword">int</span> rans = solve(mid + <span class="number">1</span>, right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//横跨分割点的情况</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, lmax = num[mid], rmax = num[mid + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid; i &gt;= left; i--) &#123;</span><br><span class="line">        sum += num[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; lmax) lmax = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        sum += num[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; rmax) rmax = sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//答案是三种情况的最大值</span></span><br><span class="line">    <span class="keyword">int</span> ans = lmax + rmax;</span><br><span class="line">    <span class="keyword">if</span>(lans &gt; ans) ans = lans;</span><br><span class="line">    <span class="keyword">if</span>(rans &gt; ans) ans = rans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入数据</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, solve(<span class="number">1</span>, N));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥦🐔刷题记录</summary>
    
    
    
    <category term="刷题" scheme="https://enchantedovo.cn/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="PTA" scheme="https://enchantedovo.cn/tags/PTA/"/>
    
  </entry>
  
  <entry>
    <title>PTA习题2-7</title>
    <link href="https://enchantedovo.cn/2021/04/20/PTA%E4%B9%A0%E9%A2%982-7/"/>
    <id>https://enchantedovo.cn/2021/04/20/PTA%E4%B9%A0%E9%A2%982-7/</id>
    <published>2021-04-20T15:59:22.000Z</published>
    <updated>2022-08-30T07:05:03.771Z</updated>
    
    <content type="html"><![CDATA[<h1>弹球距离</h1><p>设有一个球从高度为h米的地方落下，碰到地面后又弹到高度为原来p倍的位置，然后又落下，再弹起，再落下…。请编写函数求初始高度为h的球下落后到基本停下来（高度小于给定阈值TOL）时在空中所经过的路程总和。</p><p>函数接口定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double dist( double h, double p );</span><br></pre></td></tr></table></figure><p>其中h是球的初始高度，p是球弹起高度与弹起前落下高度的比值；函数dist要返回球下落后到基本停下来时在空中所经过的路程总和。注意：当弹起的高度小于裁判程序定义的常数TOL时，弹起的距离不计算在内。</p><p>裁判测试程序样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define TOL 1E-2</span><br><span class="line"></span><br><span class="line">double dist( double h, double p );</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    double h, p, d;</span><br><span class="line">    scanf(&quot;%lf %lf&quot;, &amp;h, &amp;p);</span><br><span class="line">    d &#x3D; dist(h, p);</span><br><span class="line">    printf(&quot;%.6f\n&quot;, d);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 你的代码将被嵌在这里 *&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输入样例：<br><code>1.0 0.4</code><br>输出样例：<br><code>2.319680</code></p><p><strong>递归实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double dist( double h, double p )&#123;</span><br><span class="line">    if(p*h&lt;TOL) return h;</span><br><span class="line">    else return h+h*p+dist(h*p,p);&#x2F;&#x2F;重复的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非递归实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">double dist( double h, double p )&#x2F;&#x2F;右一个注意点两次触地时走过的距离为 h+2*h*p</span><br><span class="line">&#123;</span><br><span class="line">    double mix&#x3D;h*p;</span><br><span class="line">    double sum &#x3D; h;&#x2F;&#x2F;第一次落下走过的距离是h</span><br><span class="line">    while(mix&gt;&#x3D;TOL)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+&#x3D; 2*mix;&#x2F;&#x2F;第二次落下走过的是 h+2*h*p，依次类推</span><br><span class="line">        mix &#x3D; mix*p;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥦🐔刷题记录</summary>
    
    
    
    <category term="刷题" scheme="https://enchantedovo.cn/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="PTA" scheme="https://enchantedovo.cn/tags/PTA/"/>
    
  </entry>
  
  <entry>
    <title>雅思写作Task1</title>
    <link href="https://enchantedovo.cn/2021/02/12/IELTS1/"/>
    <id>https://enchantedovo.cn/2021/02/12/IELTS1/</id>
    <published>2021-02-12T14:43:18.000Z</published>
    <updated>2021-02-16T08:09:00.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小作文基本了解">小作文基本了解</h2><h3 id="得分-时间-要求">得分+时间+要求</h3><p>小作文得分占比1/3，时间约20分钟，要求不少于150字<br><a href="https://pic1.zhimg.com/v2-e947841f5b3f71e49f8e315fdc1841c6_r.jpg?source=172ae18bhttps://pic1.zhimg.com/v2-e947841f5b3f71e49f8e315fdc1841c6_r.jpg?source=172ae18b">https://pic1.zhimg.com/v2-e947841f5b3f71e49f8e315fdc1841c6_r.jpg?source=172ae18bhttps://pic1.zhimg.com/v2-e947841f5b3f71e49f8e315fdc1841c6_r.jpg?source=172ae18b</a></p><h3 id="类型">类型</h3><ol><li><p>按整体</p><ul><li>动态图</li><li>静态图</li></ul></li><li><p>按图形</p><ul><li>线形图（Line Graph）</li><li>柱状图（Bar Chart）</li><li>饼状图（Pie Chart）</li><li>表格（Table）</li><li>流程图（Diagran）</li><li>地图题（Map）</li></ul></li></ol><h2 id="动态图">动态图</h2><h3 id="写作思路">写作思路</h3><h4 id="开头改写">开头改写</h4><ul><li>show 的同义替换 （give information about/illustrate/demonstrate）</li><li>between and 与 from to 的替换</li><li>抽象与具体的互换：three kinds of books</li><li>名词与句子的互换：show how sth changed</li></ul><h4 id="中间段思路">中间段思路</h4><p>1.多条线，找趋势</p><ul><li>趋势相同放在一起 also （but much less significantly/much more significantly）<ul><li>Likewise, such a pattern could be found in xxx.</li></ul></li><li>趋势不同用转折 however</li><li>两条线相交 overtake/outnumber<br>2.单条线，找主要数据（最高点、最低点、起点、终点、拐点），不需要所有的数据都写，写单条线要追求语法的多样性</li><li>有拐点的可以用 before，after 句型</li><li>描述的对象做主语<ul><li>The number of the rabbits increased.</li></ul></li><li>时间做主语 witness<ul><li>The four year period witnessed an upward trend in the number of rabbits.</li></ul></li><li>趋势做主语 occur<ul><li>An upward trend occurred in the number of rabbits</li></ul></li><li>there be 做主语<ul><li>There was an increase in the number of rabbits</li></ul></li></ul><h4 id="结尾段">结尾段</h4><p>总结特征+特殊点，特殊点可以用以下句式连接</p><ul><li>it is interesting/incredible to find that</li><li>interestingly/noticeably</li></ul><h3 id="举个栗子">举个栗子</h3><p>**题：**The line graph shows the sales of children’s book, adults’ fiction and educational book between 2002 and 2006 in one country.</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/12/IELTS1/eg1.png" class title="eg1"><p><strong>答：</strong></p><blockquote><p>开头改写</p></blockquote><p>The line graph compares how three different books were sold in one country from 2002 to 2006.</p><blockquote><p>中间段1：描写单条线（整体趋势——》最高点/起点——》下降趋势——》拐点）</p></blockquote><p>During the years, a downward trend occurred in the sale of adults’ fiction. In 2002, among all these books, the figure for adults’ fiction was the largest(45 million dollars). However, it dropped to almost 35 million dollars in 2003. After increasing to 40 million dollars in 2004, the figure decreased to 30 million dollars in 2006.</p><blockquote><p>中间段2：描写两条趋势相同的线（与上文对比——》figure1整体趋势——》figure2相同——》figure2不同）</p></blockquote><p>By contrast, the sale of children’s book experienced an opposite trend. It increased from 32 to 55 million dollars from 2002 to 2006. Likewise, the four-year period also witnessed an upward trend in the sale of educational books, but much less significantly. The figure increased from 25 to 31 million dollars from 2002 to 2003. After declining to 25 million dollars again, the sale climbed to 32million dollars.</p><blockquote><p>结尾（整体——》特殊点）</p></blockquote><p>Overall, the sales of these three books changed a lot. It is interesting to note that, in 2002, adults’ fiction was the most popular book. However, by the end of 2006, it had been the least popular one.</p><h3 id="有将来的变化">有将来的变化</h3><ul><li>be expected to</li><li>be predicted to</li></ul><h2 id="静态图">静态图</h2><h3 id="中间段思路-2">中间段思路</h3><ol><li>顺序<ul><li>数据从大写到小（逻辑连接词可以用 largest——》in addition——》however）</li><li>或者数据先写最大，再写最小，最后写其他（逻辑连接词 largest——》however——》in addition）</li></ul></li><li>相同的数据进行组合（with the former occupying a slightly higher proportion than the latter）</li></ol><h3 id="举个栗子-2">举个栗子</h3><p>**题：**International students 的构成: Chinese (60%), Koreans (16%), Japanese (14%), Indians (7%), Vietnamese (3%).</p><p><strong>答：</strong><br>Chinese students boast the <strong>largest</strong> share, accounting for 60 %. <strong>However</strong>, only a few international students are from India and Vietnam, and they only make up 7 % and 3 % respectively. <strong>In addition</strong> Koreans and Japanese together take up 30 %, <strong>with the former (16 %) occupying a marginally higher proportion than the latter (14 %)</strong>.</p><blockquote><p><strong>积累词汇：</strong></p><ul><li>xx boast the largest share （xx最多）</li><li>account for/make up/take up/occupy （表示占了多少份额）</li><li>,with the former (16 %) occupying a marginally higher proportion than the latter (14 %) （比较）</li></ul></blockquote><h2 id="线形图（Line-Graph）-柱状图（Bar-Chart）-表格（Table）">线形图（Line Graph）+ 柱状图（Bar Chart）+ 表格（Table）</h2><h3 id="数据描述">数据描述</h3><p>线形图里最基本的特征有升高和降低，可以用“<strong>动词+副词</strong>”或“<strong>形容词+名词</strong>”这两种表达，他们可以相互转化。</p><ol><li>动词+副词</li></ol><ul><li>动词<ul><li>上升：increase，rise，grow，climb</li><li>下降：decrease，drop，fall</li></ul></li><li>副词<ul><li>显著、大幅度：sharply，rapidly，dramatically，abruptly</li><li>持续、稳步：gradually，steadily，consistently</li><li>轻微、小幅：slightly，marginally，minimally</li></ul></li></ul><ol start="2"><li>形容词+名词</li></ol><ul><li>形容词</li><li>显著、大幅度：sharp，rapid，dramatical</li><li>持续、稳步：gradual，steadi，consistent</li><li>轻微、小幅：slight，marginal，minimal，unnoticeable</li><li>名词<ul><li>上升：increase，rise，growth</li><li>下降：decrease，drop，fall</li></ul></li></ul><p>另外，还有线形图常出现的波动、保持平稳、到达最高或最低点，这样的表达每一类能记住两个就可以了。</p><ul><li>波动<ul><li>fluctuate</li><li>experience fluctuation</li></ul></li><li>保持平稳<ul><li>remain stable</li><li>stay constant</li></ul></li><li>到达最高点<ul><li>peak at</li><li>reach the highest point of</li></ul></li><li>到达最低点<ul><li>reach the lowest point</li><li>hit a low of</li><li>bottom up at</li></ul></li><li>超过<ul><li>overtake</li><li>outnumber</li></ul></li></ul><h3 id="描述线形图的句型">描述线形图的句型</h3><ul><li>句型一：X（描述对象）+ 趋势动词 + 副词</li><li>句型二：There was a + 形容词 + 趋势名词 + in X（描述对象）</li><li>句型三：时间 + saw/ experienced/ witnessed a + 形容词 + 趋势名词</li><li>句型四：A + 形容词 + 趋势名词 + took place/ occurred.</li><li>句型五：X（描述对象）+ showed/ took +an upward/ downward trend.</li></ul><p>举个栗子：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/12/IELTS1/eg2.png" class title="eg2"><ul><li>句型一：The price of textbooks fell sharply in 2019.</li><li>句型二：There was a rapid decrease in the price of textbooks in 2019.</li><li>句型三：The year 2019 witnessed a dramatic drop in the price of textbooks.</li><li>句型四：A sharp fall in the price of textbooks took place in 2019.</li><li>句型五：The price of textbooks showed a downward trend in 2019.</li></ul><h3 id="多点数据连接">多点数据连接</h3><ul><li>连接方式一：现在分词作状语：starting at, beginning from，通常可以在描述数据的开头时使用</li></ul><blockquote><p><strong>Starting at</strong> 30, X fluctuated around this level in the first decade.（句型一）</p></blockquote><ul><li>连接方式二：表示时间的连词：before, after，后面接完整句子或者动词的进行式</li></ul><blockquote><p>X had fluctuated around this level in the first decade <strong>before</strong> it dropped abruptly to 23 in 1970.<br>如果把第一个句子也加上的话，就会变成：<br><strong>Starting at</strong> 30, X had fluctuated around this level in the first decade <strong>before</strong> dropping abruptly to 23 in 1970.（上一节里句型一的合并）</p></blockquote><ul><li>连接方式三：表示并列或转折的连词：but, however, and, in addition</li></ul><blockquote><p><strong>However</strong>, the 1970s witnessed a considerable rise（句型三）, <strong>and then</strong> a peak of 60 took place in 1980.（句型四）</p></blockquote><ul><li>连接方式四：过去分词作状语：followed by（紧接着…），后面接名词性的短语</li></ul><blockquote><p><strong>However</strong>, the 1970s witnessed a considerable rise, <strong>and then</strong> a peak of 60 took place in 1980, <strong>followed by a sharp fall over the next ten-year period.</strong></p></blockquote><ul><li>连接方式五：时间定语从句：在表示时间的词后用when引出一个非限制性定语从句</li></ul><blockquote><p>Yet, there had been a stable pattern at 8 until 2000（句型二）, <strong>when</strong> it began to increase slowly.</p></blockquote><ul><li>连接方式六：表示时间的副词：after this, following this period, thereafter</li></ul><blockquote><p><strong>Nonetheless</strong>, X is expected to show a downward trend between 2018 and 2022（句型五）, <strong>and after that</strong>, it will probably show unnoticeable rise and fall.</p></blockquote><h2 id="饼状图（Pie-Chart）">饼状图（Pie Chart）</h2><h3 id="“占比”数据的描写">“占比”数据的描写</h3><ul><li>句型一：大比例或小比例 + 主语 + 谓语，with + 数字</li><li>句型二：主语 +（表示“组成”的动词）+ 数字</li><li>句型三：单位 of 主语 + which/ who… + is + 数字</li><li>句型四：数字 + 主语 + 谓语</li><li>句型五：There be + 数字 + 主语 + which/ who…</li><li>句型六：For + 主题，数字 + 主语 + 谓语</li></ul><h3 id="举个栗子-3">举个栗子</h3><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/12/IELTS1/eg3.png" class title="eg3"><ul><li>句型一：The majority of sales in Bob’s store <strong>come from</strong> DVDs, <strong>with exactly</strong> 60%.</li><li>句型二：DVDs <strong>account for</strong> three fifths of the total sales.</li><li>句型三：<strong>The percentage</strong> of PC games sold <strong>is exactly</strong> 20%.</li><li>句型四：Fifteen percent of items sold in the store are CDs.</li><li>句型五：<strong>There is</strong> merely 5% of the total revenue <strong>generated by</strong> selling posters.</li><li>句型六：<strong>For</strong> the sales of posters, only 5% <strong>contributes to</strong> the turnover（营业额）.</li></ul><h3 id="顺序">顺序</h3><p>遇到单一个饼图的话，应该把它独立成一个主体段，段里按照不同元素的占比，从大到小按顺序写（静态图）</p><blockquote><p>It is clear from the pie chart that（开头句式，引出第一个数据） a majority of sales in Bob’s store come from DVDs, with exactly 60%. Sales are spread over other goods. (引出其余四项数据) Specifically（具体来说）, the percentage of PC games sold is exactly 20%, whereas（表示对比）fifteen percent of items sold in the store are CDs. Lastly（引出最后一个元素）, for the sales of posters, only 5% contributes to the turnover.</p></blockquote><h2 id="流程图（Diagran）">流程图（Diagran）</h2><h3 id="思路">思路</h3><ol><li>看箭头，找主要步骤</li><li>找名词，添加细节</li></ol><h3 id="举个栗子-4">举个栗子</h3><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/12/IELTS1/eg4.png" class title="eg4"><blockquote><p>总起说明</p></blockquote><p>The diagram gives information about how a hydroelectric power station generates electricity by means of the flow of water.</p><blockquote><p>主要流程（白天）</p></blockquote><p>In the daytime, water, coming from the river and kept in the high-level reservoir, flows through the intake which is under the dam and is only open during the day time. Then the water comes to the power station where the flow of water produces electricity through a generator which is operated by reversible turbines. Finally, the electricity goes from power lines to the national grid.</p><blockquote><p>特殊情况（夜晚）</p></blockquote><p>However, when it gets dark, the power station works in a reversed but easier way. Water kept in the low level reservoir is pumped by reversible turbines and finally it comes to the high level reservoir.</p><blockquote><p>总结（different——》比较）</p></blockquote><p>Overall, based on working time, the process could be divided into two different parts. In the day time, the process is far more complicated while in the night time, it is much easier.</p><h2 id="地图题（Map）">地图题（Map）</h2><h3 id="思路-2">思路</h3><ol><li>找出两幅图的变化</li><li>按照方位，依次写出建筑物的特征。第一幅图不写变化，第二幅图些变化</li></ol><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/12/IELTS1/eg5.png" class title="eg5"><h3 id="举个栗子-5">举个栗子</h3><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/12/IELTS1/eg6.png" class title="eg6"><blockquote><p>总起说明</p></blockquote><p>The two maps give information about how a village park has changed over ten years.</p><blockquote><p>描述之前（第一幅图）</p></blockquote><p>Ten years ago, there was a large football pitch in the center. To its south was a small pond, and in the southeastern corner stood woods, whose area was much larger than pond and slightly smaller than football pitch. In the north, near the border were two tennis courts. Between these two sport areas sat a car park in the west which could house 20 cars and a children’s play area in the east.</p><blockquote><p>说明变化（第二幅图）</p></blockquote><p>The football pitch now is still located in the center but occupies a marginally smaller area. In the south, the pond is used for boating now; the woods have been cleared and are replaced by a cafe. Besides, in the southwestern corner lies a new picnic area.On the northern side, the number of tennis courts has doubled and the car park has been enlarged, which means it could house 50 people currently. children’s play area has been divided into Children’s park and Children’s soft play area. In addition to changes inside the park, there is also a new cycle path around the whole area.</p><blockquote><p>总结（整体的变化）</p></blockquote><p>Overall, there are more sports facilities and parking space, and the natural spots in the south have been transformed to places for recreational activities.</p>]]></content>
    
    
    <summary type="html">雅思写作学习笔记1——小作文、图表作文</summary>
    
    
    
    <category term="雅思" scheme="https://enchantedovo.cn/categories/%E9%9B%85%E6%80%9D/"/>
    
    
    <category term="雅思写作" scheme="https://enchantedovo.cn/tags/%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/"/>
    
    <category term="英语" scheme="https://enchantedovo.cn/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>NLP基础</title>
    <link href="https://enchantedovo.cn/2021/02/12/nlp1/"/>
    <id>https://enchantedovo.cn/2021/02/12/nlp1/</id>
    <published>2021-02-12T12:21:32.000Z</published>
    <updated>2022-09-07T11:45:52.281Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考书籍：</p><ul><li>《自然语言处理理论与实战》</li><li>《Python 自然语言处理》</li><li>《Python 自然语言处理实战：核心技术与算法》</li></ul></blockquote><h2 id="NLP基本概念">NLP基本概念</h2><h3 id="什么是NLP">什么是NLP</h3><p>NLP定义：自然语言处理，用计算机处理、理解以及运行的人类语言（如中文、英文等）</p><p>NLP分类：</p><ul><li>自然语言理解<ul><li>音系学：语法中发讯的系统化组织</li><li>词态学：研究单词构成及相互关系</li><li>句法学：给定文本哪部分是语法正确的</li><li>语义句法学：给定文本的含义是什么？</li><li>语法学：文本的目的是什么？</li></ul></li><li>自然语言处理<ul><li>自然语言文本</li></ul></li></ul><p>NLP的研究任务</p><ul><li>机器翻译：计算机具备将一种语言<strong>翻译成另一种语言</strong>的能力</li><li>情感分析：计算机能够判断用户评论<strong>是否积极</strong></li><li>智能问答：计算机能够正确<strong>回答输入的问题</strong></li><li>文摘生成：计算机能够准确<strong>归纳、总结并产生文本摘要</strong></li><li>文本分类：计算机能够采集各种文章，进行<strong>主题分析</strong>，从而进行<strong>自动分类</strong></li><li>舆论分析：计算机能够<strong>判断目前舆论的导向</strong></li><li>知识图谱：知识点相互连接而成的<strong>语义网络</strong></li></ul><h2 id="NLP常用术语">NLP常用术语</h2><ul><li>分词（segment）<ul><li>将句子分成独立的有意义的语言成分（词）</li></ul></li><li>词性标注（part-of-speech tagging）<ul><li>对词的词性进行标注（例：动词、名词、形容词）</li></ul></li><li>命名实体识别（NER, Named Entity Recognition）<ul><li>从文本中识别具有特定类别的实体（例：人名、地名、机构名等）</li></ul></li><li>句法分析（syntax parsing）<ul><li>分析句子各个成分的依赖关系（例：主从关系），最后可生成句法分析树</li></ul></li><li>指代消解（anaphora resolution）<ul><li>代词指代</li></ul></li><li>情感识别（emotion recognition）<ul><li>本质是分类问题，经常应用在舆情分析等领域，可分为两类（正面、负面）或者三类（+中性）</li></ul></li><li>纠错（correction）<ul><li>在搜索技术和输入法中利用很多，具体做法可以根据N-Gram、字典树等等方法</li></ul></li><li>问答系统（QA system）<ul><li>类似机器人的人工智能系统</li></ul></li></ul><h2 id="语料库">语料库</h2><ul><li>中文维基百科</li><li>搜狗新闻语料库</li><li>IMDB情感分析语料库</li><li>等</li></ul><h2 id="三个层次">三个层次</h2><ul><li>词法分析</li><li>句法分析</li><li>语义分析</li></ul>]]></content>
    
    
    <summary type="html">自然语言处理学习笔记1——基础知识</summary>
    
    
    
    <category term="自然语言处理" scheme="https://enchantedovo.cn/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
    <category term="自然语言处理" scheme="https://enchantedovo.cn/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    <category term="python" scheme="https://enchantedovo.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>seaborn</title>
    <link href="https://enchantedovo.cn/2021/02/03/seaborn/"/>
    <id>https://enchantedovo.cn/2021/02/03/seaborn/</id>
    <published>2021-02-03T03:12:39.000Z</published>
    <updated>2021-02-12T12:29:37.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="seaborn简介">seaborn简介</h2><p><code>seaborn</code>同<code>matplotlib</code>一样，是Python进行数据可视化分析的重要第三方包。但<code>seaborn</code>是在<code>matplotlib</code>的基础上进行了<strong>更高级的API封装</strong>。使用<code>seaborn</code>，可以在不需要了解那么多底层参数的情况下，同样能够画出比较好看的图表。</p><h2 id="seaborn使用">seaborn使用</h2><h3 id="安装-导入">安装&amp;导入</h3><p>首先确定你的电脑已安装以下应用</p><ul><li>Python 2.7+ or Python 3</li><li>Pandas</li><li>Matplotlib</li><li>Seaborn</li><li>Jupyter Notebook(可选)</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>出现jupyternotebook的界面，即可进行代码编写：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/03/seaborn/img1.png" class title="img1"><p>导入相关包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><h3 id="seaborn绘图风格">seaborn绘图风格</h3><p>首先定义一个简单的方程来绘制一些偏置的正弦波：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sinplot</span>(<span class="params">flip=<span class="number">1</span></span>):</span></span><br><span class="line">    x = np.linspace(<span class="number">0</span>, <span class="number">14</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">        plt.plot(x, np.sin(x + i * <span class="number">.5</span>) * (<span class="number">7</span> - i) * flip)</span><br></pre></td></tr></table></figure><p><code>matplotlib</code>默认会绘制如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinplot()</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/03/seaborn/img2.png" class title="img2"><p>转换为<code>seaborn</code>默认绘图，可以简单的用set()方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.<span class="built_in">set</span>()</span><br><span class="line">sinplot()</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/03/seaborn/img3.png" class title="img3"><p>有五种seaborn的风格，它们分别是：</p><ul><li>darkgrid（默认）</li><li>whitegrid</li><li>dark</li><li>white</li><li>ticks</li></ul><p>另外可以自己设置相关配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.set_style(<span class="string">&quot;darkgrid&quot;</span>, &#123;<span class="string">&quot;axes.facecolor&quot;</span>: <span class="string">&quot;.9&quot;</span>&#125;)</span><br><span class="line">sinplot()</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/03/seaborn/img4.png" class title="img4"><h3 id="数据可视化demo">数据可视化demo</h3><p>对数据的可视化操作，乍看起来很复杂，其实种类总结起来可以分为下面几种：</p><ul><li>单变量分布可视化(displot)</li><li>双变量分布可视化(jointplot)</li><li>数据集中成对双变量分布(pairplot)</li><li>双变量-三变量散点图(relplot)</li><li>双变量-三变量连线图(relplot)</li><li>双变量-三变量简单拟合</li><li>分类数据的特殊绘图</li></ul><h4 id="单变量分布">单变量分布</h4><p>单变量分布可视化是通过将单变量数据进行统计从而实现画出概率分布的功能，<strong>同时</strong>概率分布有<strong>直方图</strong>与<strong>概率分布曲线</strong>两种形式。<br>利用displot()对单变量分布画出直方图(可以取消)，并自动进行概率分布的拟合(也可以使用参数取消)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.set_style(<span class="string">&#x27;darkgrid&#x27;</span>)</span><br><span class="line">x = np.random.randn(<span class="number">300</span>)</span><br><span class="line">sns.distplot(x);</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/03/seaborn/img5.png" class title="img5"><p>还可以使用sns.kdeplot()画出核密度估计图。核密度估计是概率论上用来估计未知的密度函数，属于非参数检验，通过核密度估计图可以比较直观的看出样本数据本身的分布特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=np.random.randn(<span class="number">100</span>)</span><br><span class="line"><span class="comment">#是否进行阴影处理</span></span><br><span class="line">sns.kdeplot(x,shade=<span class="literal">True</span>,color=<span class="string">&quot;g&quot;</span>)</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/03/seaborn/img6.png" class title="img6"><p>二元kde图像，很少使用，稍微了解一下即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#x,y</span></span><br><span class="line">y=np.random.randn(<span class="number">100</span>)</span><br><span class="line"><span class="comment">#cbar：参数若为True，则会添加一个颜色棒(颜色帮在二元kde图像中才有)</span></span><br><span class="line">sns.kdeplot(x,y,shade=<span class="literal">True</span>,cbar=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/03/seaborn/img7.png" class title="img7"><h4 id="双变量分布">双变量分布</h4><p>双变量分布通俗来说就是分析两个变量的联合概率分布和每一个变量的分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">mean, cov = [<span class="number">0</span>, <span class="number">1</span>], [(<span class="number">1</span>, <span class="number">.5</span>), (<span class="number">.5</span>, <span class="number">1</span>)]</span><br><span class="line">data = np.random.multivariate_normal(mean, cov, <span class="number">200</span>)</span><br><span class="line">df = pd.DataFrame(data, columns=[<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>])</span><br><span class="line">sns.jointplot(x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, data=df);</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/03/seaborn/img8.png" class title="img8"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同样可以使用曲线来拟合分布密度</span></span><br><span class="line">sns.jointplot(x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, data=df, kind=<span class="string">&quot;kde&quot;</span>);</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/03/seaborn/img9.png" class title="img9"><h4 id="数据集中成对双变量分析">数据集中成对双变量分析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对角线化的是单变量的分布</span></span><br><span class="line">iris = sns.load_dataset(<span class="string">&quot;iris&quot;</span>)</span><br><span class="line">sns.pairplot(iris);</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/03/seaborn/img10.png" class title="img10"><p>可以进行一些配置：</p><ul><li>hue——》指定分类变量</li><li>markers——》使用不同的形状</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g1 = sns.pairplot(iris, hue=<span class="string">&quot;species&quot;</span>, markers=[<span class="string">&quot;o&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;D&quot;</span>])</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/03/seaborn/img11.png" class title="img11"><p>还有其他配置如下:</p><ul><li>使用调色板</li><li>使用 KDE</li><li>使用回归</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g2 = sns.pairplot(iris, hue=<span class="string">&quot;species&quot;</span>, palette=<span class="string">&quot;husl&quot;</span>)</span><br><span class="line">g3 = sns.pairplot(iris, diag_kind=<span class="string">&quot;kde&quot;</span>)</span><br><span class="line">g4 = sns.pairplot(iris, kind=<span class="string">&quot;reg&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="双变量-三变量散点图">双变量-三变量散点图</h4><p>这里使用tips数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)</span><br><span class="line">sns.relplot(x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips);</span><br><span class="line"><span class="comment"># 除了画出双变量的散点图外，还可以利用颜色来增加一个维度将点分离开</span></span><br><span class="line">sns.relplot(x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, hue=<span class="string">&quot;smoker&quot;</span>, data=tips);</span><br></pre></td></tr></table></figure><p><strong>通过hue设置来进行区分</strong></p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/03/seaborn/img11.png" class title="img11"><h4 id="简单线性拟合">简单线性拟合</h4><p>主要用regplot()进行画图，这个函数绘制两个变量的散点图，x和y，然后拟合回归模型并绘制得到的回归直线和该回归一个95％置信区间。<br>（不过一般这种工作可以用sklearn来做）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.set_style(<span class="string">&#x27;darkgrid&#x27;</span>)</span><br><span class="line">sns.regplot(x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips);</span><br></pre></td></tr></table></figure><p>线性模型对某些数据可能适应不够好，可以使用高阶模型拟合，也可以删除部分数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用order2阶模型来拟合</span></span><br><span class="line">sns.regplot(x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, data=anscombe.query(<span class="string">&quot;dataset == &#x27;II&#x27;&quot;</span>),ci=<span class="literal">None</span>,order = <span class="number">2</span>);</span><br><span class="line"><span class="comment"># 如果数据中有明显错误的数据点可以进行删除</span></span><br><span class="line">sns.regplot(x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, data=anscombe.query(<span class="string">&quot;dataset == &#x27;III&#x27;&quot;</span>),ci=<span class="literal">None</span>);</span><br><span class="line">plt.figure()</span><br><span class="line">sns.regplot(x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, data=anscombe.query(<span class="string">&quot;dataset == &#x27;III&#x27;&quot;</span>),ci=<span class="literal">None</span>,robust = <span class="literal">True</span>);</span><br></pre></td></tr></table></figure><h4 id="热力图">热力图</h4><p>取出三个特征进行热力图的绘制figures.pivot() 其中第三个属性表示热力图上实际的值。<br>常用设置：</p><ul><li>annot：是否显示数值注释</li><li>fmt：format的缩写，设置数值的格式化形式</li><li>linewidths：热力图矩阵之间的间隔大小</li><li>vmax,vmin：图例中最大值和最小值的显示值，没有该参数时默认不显示</li><li>cmap：matplotlib的colormap名称或颜色对象；如果没有提供，默认为：<ul><li>cubehelix map (数据集为连续数据集时)</li><li>RdBu_r (数据集为离散数据集时)</li></ul></li><li>xticklabels, yticklabels：绘制dataframe的行列名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">flights = sns.load_dataset(<span class="string">&#x27;flights&#x27;</span>)</span><br><span class="line"><span class="comment"># 取出这三个属性画热力图，坐标点的位置是passengers</span></span><br><span class="line">flights = flights.pivot(<span class="string">&#x27;month&#x27;</span>, <span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;passengers&#x27;</span>)</span><br><span class="line">ax = sns.heatmap(flights)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将实际的数值绘制到上面</span></span><br><span class="line">flights = sns.load_dataset(<span class="string">&#x27;flights&#x27;</span>)</span><br><span class="line"><span class="comment"># 取出这三个属性画热力图，坐标点的位置是passengers</span></span><br><span class="line">flights = flights.pivot(<span class="string">&#x27;month&#x27;</span>, <span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;passengers&#x27;</span>)</span><br><span class="line">ax = sns.heatmap(flights, annot=<span class="literal">True</span>, fmt=<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/2021/02/03/seaborn/img12.png" class title="img12"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line">ax = sns.heatmap(flights, fmt=<span class="string">&#x27;d&#x27;</span>, linewidths=<span class="number">.5</span>, cmap=<span class="string">&#x27;YlGnBu&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据可视化学习(≖ᴗ≖)✧</summary>
    
    
    
    <category term="可视化" scheme="https://enchantedovo.cn/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
    <category term="python" scheme="https://enchantedovo.cn/tags/python/"/>
    
    <category term="可视化" scheme="https://enchantedovo.cn/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
</feed>
